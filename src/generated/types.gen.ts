// This file is auto-generated by @hey-api/openapi-ts

export type Page = {
    /**
     * A record id. Results will only contain the records that come after the specified record.
     * Only one of `after` or `before` can be provided, not both.
     *
     */
    after?: string
    /**
     * A record id. Results will only contain the records that come before the specified record.
     * Only one of `after` or `before` can be provided, not both.
     *
     */
    before?: string
    /**
     * The number of records to return. Does not apply to the `listMessages` endpoint.
     */
    size?: number
}

export type DisplayName = string | null

/**
 * Customizable app settings.
 */
export type AppSettings = {
    /**
     * Number of seconds of inactivity before a conversation’s messages
     * will be automatically deleted. See
     * [Conversation Retention Seconds](https://docs.smooch.io/guide/creating-and-managing-apps/#conversation-retention-seconds)
     * for more information.
     *
     */
    conversationRetentionSeconds?: number
    /**
     * A boolean specifying whether credit card numbers should be masked
     * when sent through Sunshine Conversations.
     *
     */
    maskCreditCardNumbers?: boolean
    /**
     * A boolean specifying whether animal names should be used for
     * unnamed users. See the
     * [user naming guide](https://docs.smooch.io/guide/receiving-messages/#message-author-name)
     * for details.
     *
     */
    useAnimalNames?: boolean
    /**
     * A boolean specifying whether a message should be added to the conversation
     * history when a postback button is clicked. See
     * [Echo Postbacks](https://docs.smooch.io/guide/creating-and-managing-apps/#echo-postbacks)
     * for more information.
     *
     */
    echoPostback?: boolean
    /**
     * A boolean specifying whether a non message event coming from a channel will
     * trigger a
     * [start conversation](https://docs.smooch.io/rest/#section/Webhook-Triggers)
     * event and count as a monthly active user (MAU).
     * <aside class="notice">Calling <code>startConversation()</code> (or equivalent) from the Android,
     * iOS or Web SDK will count as a MAU, regardless of the value of this setting.</aside>
     *
     */
    ignoreAutoConversationStart?: boolean
    /**
     * A boolean specifying whether users are allowed to be part of several conversations.
     * Enabling `multiConvo` is **irreversible**.
     *
     */
    multiConvoEnabled?: boolean
    /**
     * A boolean specifying whether the messages authored by the Sunshine Conversations platform should be localized.
     *
     */
    appLocalizationEnabled?: boolean
}

/**
 * Flat object containing custom properties. Strings, numbers and booleans
 * are the only supported format that can be passed to metadata.
 * The metadata is limited to 4KB in size.
 *
 */
export type Metadata = {
    [key: string]: unknown
} | null

export type App = {
    /**
     * A canonical ID that can be used to retrieve the Sunshine Conversations app.
     */
    id?: string
    /**
     * The friendly name of the app.
     */
    displayName?: DisplayName
    settings?: AppSettings
    metadata?: Metadata
}

/**
 * Response metadata.
 */
export type Meta = {
    /**
     * A flag that indicates if there are more records that can be fetched.
     */
    hasMore?: boolean
    /**
     * A record id that can be used as a `page[after]` parameter in a new request to get the next page.
     * Not specified if there are no subsequent pages.
     *
     */
    afterCursor?: string
    /**
     * A record id that can be used as a `page[before]` parameter in a new request to get the previous page.
     * Not specified if there are no previous pages.
     *
     */
    beforeCursor?: string
}

/**
 * Previous and next page links, if they exist.
 */
export type Links = {
    /**
     * A link to the previous page. Not specified if there are no previous pages.
     */
    prev?: string
    /**
     * A link to the next page. Not specified if there are no subsequent pages.
     */
    next?: string
}

export type AppListResponse = {
    /**
     * List of returned apps.
     */
    apps?: Array<App>
    meta?: Meta
    links?: Links
}

export type _Error = {
    /**
     * Error code used for classifying similar error types
     */
    code?: string
    /**
     * Description of the error
     */
    title?: string
}

export type ErrorResponse = {
    /**
     * List of errors that occurred.
     */
    errors?: Array<_Error>
}

/**
 * AppCreateBody
 */
export type AppCreateBody = {
    /**
     * The friendly name of the app.
     */
    displayName: DisplayName
    settings?: AppSettings
    metadata?: Metadata
}

/**
 * AppResponse
 */
export type AppResponse = {
    /**
     * The app.
     */
    app?: App
}

export type AppUpdateBody = {
    /**
     * The friendly name of the app.
     */
    displayName?: DisplayName
    settings?: AppSettings
    metadata?: Metadata
}

export type AppKey = {
    /**
     * The unique ID of the API key, used when signing JWTs or accessing the API using Basic Authentication.
     */
    id?: string
    /**
     * The name of the API key.
     */
    displayName?: string
    /**
     * The secret of the API key, used when signing JWTs or accessing the API using Basic Authentication
     */
    secret?: string
}

export type AppKeyListResponse = {
    /**
     * List of returned keys.
     */
    keys?: Array<AppKey>
}

/**
 * AppKeyResponse
 */
export type AppKeyResponse = {
    /**
     * The created key object.
     */
    key?: AppKey
}

export type AttachmentUploadBody = {
    source: Blob | File
}

export type AttachmentSchema = {
    /**
     * Uploaded attachment’s url.
     * <aside class="notice">Note that for private attachments an authorization header is required to access the mediaUrl. See [configuring private attachments for messaging](https://developer.zendesk.com/documentation/zendesk-web-widget-sdks/messaging_private_attachments/) guide for more details.</aside>
     *
     */
    mediaUrl?: string
    /**
     * Uploaded attachment's media type
     */
    mediaType?: string
}

/**
 * AttachmentResponse
 */
export type AttachmentResponse = {
    /**
     * The uploaded attachment object.
     */
    attachment?: AttachmentSchema
}

export type AttachmentDeleteBody = {
    /**
     * The media URL used for a file or image message.
     */
    mediaUrl: string
}

/**
 * The type of the conversation.
 */
export type ConversationType = 'personal' | 'sdkGroup'

/**
 * Identifier for use in control transfer protocols. Restricted to alphanumeric characters, `-` and `_`.
 */
export type Name = string

/**
 * Id of the integration that should deliver events routed by the switchboard.
 */
export type SwitchboardIntegrationId = string

/**
 * Type of integration that should deliver events routed by the switchboard. If referencing an OAuth integration, the clientId issued by Sunshine Conversations during the OAuth partnership process will be the value of integrationType.
 */
export type SwitchboardIntegrationType = string

export type SwitchboardIntegrationWebhook = {
    /**
     * The unique ID of the switchboard integration.
     */
    id?: string
    name?: Name
    integrationId?: SwitchboardIntegrationId
    integrationType?: SwitchboardIntegrationType
}

export type ConversationTruncated = {
    /**
     * The unique ID of the conversation.
     */
    id?: string
    type?: ConversationType
    metadata?: Metadata
    /**
     * The current switchboard integration that is in control of the conversation. This field is omitted if no `activeSwitchboardIntegration` exists for the conversation.
     */
    activeSwitchboardIntegration?: SwitchboardIntegrationWebhook | null
    /**
     * The switchboard integration that is awaiting control. This field is omitted if no switchboard integration has been previously offered control.
     */
    pendingSwitchboardIntegration?: SwitchboardIntegrationWebhook | null
}

/**
 * A short text describing the conversation.
 */
export type Description = string | null

/**
 * A custom conversation icon url. The image must be in either JPG, PNG, or GIF format
 */
export type Icon = string | null

export type Conversation = ConversationTruncated & {
    /**
     * Whether the conversation is the default conversation for the user. Will be
     * true for the first personal conversation created for the user, and false in
     * all other cases.
     *
     */
    isDefault?: boolean
    /**
     * A friendly name for the conversation, may be displayed to the business or
     * the user.
     *
     */
    displayName?: DisplayName
    description?: Description
    iconUrl?: Icon
    /**
     * A datetime string with the format YYYY-MM-DDThh:mm:ss.SSSZ
     * representing the moment the conversation was last marked as read with
     * role business.
     *
     */
    businessLastRead?: string | null
    /**
     * A datetime string with the format YYYY-MM-DDThh:mm:ss.SSSZ
     * representing the moment the last message was received in the
     * conversation, or the creation time if no messages have been received yet.
     *
     */
    lastUpdatedAt?: string | null
    /**
     * A datetime string with the format YYYY-MM-DDThh:mm:ss.SSSZ
     * representing the creation time of the conversation.
     *
     */
    createdAt?: string
}

export type ConversationListResponse = {
    /**
     * List of returned conversations.
     */
    conversations?: Array<Conversation>
    meta?: Meta
    links?: Links
}

export type ParticipantSubSchema =
    | {
          /**
           * The id of the user that will be participating in the conversation. It will return `404` if the user can’t be found. One of `userId` or `userExternalId` is required, but not both.
           */
          userId?: string
          /**
           * When passed as true, the SDK client of the concerned participant will be subscribed to the conversation. The user will start receiving push notifications for this conversation right away, without having to view the conversation on the SDK beforehand. An SDK client will be created for users that don’t already have one. This field is required if the conversation is of type `sdkGroup`.
           */
          subscribeSDKClient?: boolean
      }
    | {
          /**
           * The `externalId` of the user that will be participating in the conversation. It will return `404` if the user can’t be found. One of `userId` or `userExternalId` is required, but not both.
           */
          userExternalId?: string
          /**
           * When passed as true, the SDK client of the concerned participant will be subscribed to the conversation. The user will start receiving push notifications for this conversation right away, without having to view the conversation on the SDK beforehand. An SDK client will be created for users that don’t already have one. This field is required if the conversation is of type `sdkGroup`.
           */
          subscribeSDKClient?: boolean
      }

/**
 * ConversationCreateBody
 */
export type ConversationCreateBody = {
    type: ConversationType
    /**
     * The users participating in the conversation. For `personal` conversations, this field is required with a length of exactly 1. For `sdkGroup` conversations, must have a length less than or equal to 10.
     * Can be omitted to have a conversation with no participants if the type is `sdkGroup`.
     *
     */
    participants?: Array<ParticipantSubSchema>
    /**
     * A friendly name for the conversation, may be displayed to the business or
     * the user.
     *
     */
    displayName?: DisplayName
    description?: Description
    iconUrl?: Icon
    metadata?: Metadata
}

/**
 * ConversationResponse
 */
export type ConversationResponse = {
    /**
     * The conversation.
     */
    conversation?: Conversation
}

export type ConversationUpdateBody = {
    /**
     * A friendly name for the conversation, may be displayed to the business or
     * the user.
     *
     */
    displayName?: DisplayName
    description?: Description
    iconUrl?: Icon
    metadata?: Metadata
}

export type ParticipantJoinBody = ParticipantSubSchema

/**
 * The type of integration that the client represents. Can be any of the supported integration types, or sdk for integrations of type ios, android, unity and web.
 */
export type ClientType =
    | 'apple'
    | 'gbm'
    | 'googlercs'
    | 'instagram'
    | 'kakao'
    | 'line'
    | 'mailgun'
    | 'messagebird'
    | 'messenger'
    | 'slackconnect'
    | 'sdk'
    | 'telegram'
    | 'twilio'
    | 'twitter'
    | 'viber'
    | 'wechat'
    | 'whatsapp'

export type ClientAssociation = {
    type?: ClientType
    /**
     * The id of the client being referenced.
     */
    clientId?: string
}

export type Participant = {
    /**
     * The unique ID of the participant.
     */
    id?: string
    /**
     * The id of the associated user.
     */
    userId?: string
    /**
     * Number of messages the user has not yet read.
     */
    unreadCount?: number
    /**
     * Represents the clients that are active in the conversation for a particular
     * user. A participant can have multiple clientAssociations in the case of
     * channel transfer, business initiated conversations, or identified users.
     * The order of the array indicates how recently a client has interacted with
     * the conversation, with the most recent client first. The first item in the
     * array is considered to be the user's primary client for that conversation,
     * and will be selected first for message delivery.
     *
     */
    clientAssociations?: Array<ClientAssociation>
    /**
     * The externalId of the associated user.
     */
    userExternalId?: string | null
    /**
     * A datetime string with the format YYYY-MM-DDThh:mm:ss.SSSZ representing the latest message the user has read.
     */
    lastRead?: string | null
}

/**
 * List of returned participants.
 */
export type ParticipantListResponse = {
    participants?: Array<Participant>
    meta?: Meta
    links?: Links
}

export type ParticipantLeaveBody =
    | {
          /**
           * The id of the user that will be removed from the conversation. It will
           * return 404 if the user can’t be found.
           *
           */
          userId?: string
      }
    | {
          /**
           * The externalId of the user that will be removed from the conversation. It
           * will return 404 if the user can’t be found.
           *
           */
          userExternalId?: string
      }
    | {
          /**
           * The participantId of the user that will be removed from the conversation.
           * It will return 404 if the user can’t be found.
           *
           */
          participantId?: string
      }

/**
 * The author of the message.
 */
export type AuthorReadable = {
    /**
     * The author type. Either "user" (representing the end user)
     * or "business" (sent on behalf of the business).
     *
     */
    type: 'business' | 'user'
    /**
     * A string array that indicates the author's subtypes. Messages from "business" type with an "AI" subtype
     * are generated by AI and a disclaimer is appended to the text of the message sent to the customer.
     * For third-party channels, the disclaimer is applied for image, file, and text message types.
     * Message with an "activity" subtype are generated by system activities.
     *
     */
    subtypes?: Array<'AI' | 'activity'>
    /**
     * The id of the user. Only supported when `type` is user.
     */
    userId?: string
    /**
     * The display name of the message author.
     */
    displayName?: string
    /**
     * A custom message icon URL. The image must be JPG, PNG, or GIF format.
     */
    avatarUrl?: Icon
}

/**
 * The author of the message.
 */
export type AuthorWritable = {
    /**
     * The author type. Either "user" (representing the end user)
     * or "business" (sent on behalf of the business).
     *
     */
    type: 'business' | 'user'
    /**
     * A string array that indicates the author's subtypes. Messages from "business" type with an "AI" subtype
     * are generated by AI and a disclaimer is appended to the text of the message sent to the customer.
     * For third-party channels, the disclaimer is applied for image, file, and text message types.
     * Message with an "activity" subtype are generated by system activities.
     *
     */
    subtypes?: Array<'AI' | 'activity'>
    /**
     * The id of the user. Only supported when `type` is user.
     */
    userId?: string
    /**
     * The externalId of the user. Only supported when `type` is user.
     */
    userExternalId?: string
    /**
     * The display name of the message author.
     */
    displayName?: string
    /**
     * A custom message icon URL. The image must be JPG, PNG, or GIF format.
     */
    avatarUrl?: Icon
}

export type TicketClosedReadable = {
    /**
     * The type of system activity that generated the message. The value of this field determines the dynamic content that is rendered to the end-user / agent when viewing this message. Each `type` value will have a set of pre-defined, localized strings that describe the activity.
     */
    type: string
    /**
     * No additional data is supplied with the "ticket:closed" activity type at this time.
     */
    data?: {
        [key: string]: unknown
    }
}

export type TicketClosedWritable = {
    /**
     * The type of system activity that generated the message. The value of this field determines the dynamic content that is rendered to the end-user / agent when viewing this message. Each `type` value will have a set of pre-defined, localized strings that describe the activity.
     */
    type: string
    /**
     * No additional data is supplied with the "ticket:closed" activity type at this time.
     */
    data?: {
        [key: string]: unknown
    }
}

export type TransferToEmailReadable = {
    /**
     * The type of system activity that generated the message. The value of this field determines the dynamic content that is rendered to the end-user / agent when viewing this message. Each `type` value will have a set of pre-defined, localized strings that describe the activity.
     */
    type: string
    /**
     * No additional data is supplied with the "ticket:transfer:email" activity type at this time.
     */
    data?: {
        [key: string]: unknown
    }
}

export type TransferToEmailWritable = {
    /**
     * The type of system activity that generated the message. The value of this field determines the dynamic content that is rendered to the end-user / agent when viewing this message. Each `type` value will have a set of pre-defined, localized strings that describe the activity.
     */
    type: string
    /**
     * No additional data is supplied with the "ticket:transfer:email" activity type at this time.
     */
    data?: {
        [key: string]: unknown
    }
}

export type ActivityMessageReadable =
    | ({
          type: 'ticket:closed'
      } & TicketClosedReadable)
    | ({
          type: 'ticket:transfer:email'
      } & TransferToEmailReadable)

export type ActivityMessageWritable =
    | ({
          type: 'ticket:closed'
      } & TicketClosedWritable)
    | ({
          type: 'ticket:transfer:email'
      } & TransferToEmailWritable)

/**
 * HTML text content of the message. Can be provided in place of `text`. Cannot be used with `markdownText`.
 * If no `text` is provided, will be converted to `text` upon reception to be displayed on channels that do not support rich text.
 * See [rich text](https://docs.smooch.io/guide/structured-messages/rich-text) documentation for more information.
 */
export type HtmlText = string

/**
 * Markdown text content of the message. Can be provided in place of `text`. Cannot be used with `htmlText`.
 * Will be converted to `htmlText` upon reception. If converted `htmlText` exceeds 4096 characters, the message will be rejected.
 * If no `text` is provided, will be converted to `text` upon reception to be displayed on channels that do not support rich text.
 * See [rich text](https://docs.smooch.io/guide/structured-messages/rich-text) documentation for more information.
 */
export type MarkdownText = string

export type Buy = {
    /**
     * The type of action.
     */
    type: string
    /**
     * The button text.
     */
    text: string
    /**
     * The amount being charged. It needs to be specified in cents and is an integer (9.99$ -> 999).
     */
    amount: number
    /**
     * An ISO 4217 standard currency code in lowercase. Used for actions of type buy.
     */
    currency?: string
    metadata?: Metadata
}

/**
 * Extra options to pass directly to the channel API.
 */
export type ExtraChannelOptions = {
    /**
     * Messenger channel options.
     */
    messenger?: {
        /**
         * For webview type actions, a boolean value indicating whether the URL should be loaded with Messenger Extensions enabled. [More info](https://developers.facebook.com/docs/messenger-platform/send-api-reference/url-button).
         */
        messenger_extensions?: boolean
        /**
         * For webview type actions, a string value indicating if the share button should be hidden. [More Info](https://developers.facebook.com/docs/messenger-platform/reference/buttons/url).
         */
        webview_share_button?: 'hide'
    }
}

/**
 * A link action will open the provided URI when tapped.
 */
export type Link = {
    /**
     * The type of action.
     */
    type: string
    /**
     * The action URI. This is the link that will be used in the clients when clicking the button.
     */
    uri: string
    /**
     * The button text.
     */
    text: string
    /**
     * Boolean value indicating whether the action is the default action for a message item in Facebook Messenger.
     */
    default?: boolean
    metadata?: Metadata
    extraChannelOptions?: ExtraChannelOptions
}

/**
 * A location request action will prompt the user to share their location.
 */
export type LocationRequest = {
    /**
     * The type of action.
     */
    type: string
    /**
     * The button text.
     */
    text: string
    metadata?: Metadata
}

export type Postback = {
    /**
     * The type of action.
     */
    type: string
    /**
     * The button text.
     */
    text: string
    /**
     * The payload of a postback or reply button.
     */
    payload: string
    metadata?: Metadata
}

export type Reply = {
    /**
     * The type of action.
     */
    type: string
    /**
     * The button text. We recommend a non-empty value because some channels may not support empty ones. Text longer than 20 characters will be truncated on Facebook Messenger, and longer than 40 characters will be truncated on Web Messenger, iOS, and Android.
     */
    text: string
    /**
     * A string payload to help you identify the action context. Used when posting the reply. You can also use metadata for more complex needs.
     */
    payload: string
    metadata?: Metadata
    /**
     * An icon to render next to the reply option.
     */
    iconUrl?: string
}

/**
 * When a webview actions is clicked/tapped, the provided URI will be loaded in a webview. Channels that do not support webviews will open the fallback URI instead.
 */
export type Webview = {
    /**
     * The type of action.
     */
    type: string
    /**
     * The webview URI. This is the URI that will open in the webview when clicking the button.
     */
    uri: string
    /**
     * The button text.
     */
    text: string
    /**
     * Boolean value indicating whether the action is the default action for a message item in Facebook Messenger.
     */
    default?: boolean
    metadata?: Metadata
    extraChannelOptions?: ExtraChannelOptions
    /**
     * The size to display a webview. Used for actions of type webview.
     */
    size?: 'compact' | 'tall' | 'full'
    /**
     * The fallback uri for channels that don’t support webviews. Used for actions of type webview.
     */
    fallback: string
    /**
     * Boolean value indicating if the webview should open automatically. Only one action per message can be set to true. Currently only supported on the Web Messenger.
     */
    openOnReceive?: boolean
}

export type Action =
    | ({
          type: 'buy'
      } & Buy)
    | ({
          type: 'link'
      } & Link)
    | ({
          type: 'locationRequest'
      } & LocationRequest)
    | ({
          type: 'postback'
      } & Postback)
    | ({
          type: 'reply'
      } & Reply)
    | ({
          type: 'webview'
      } & Webview)

export type TextMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The text content of the message. Required unless `actions`, `htmlText` or `markdownText` is provided.
     */
    text?: string
    htmlText?: HtmlText
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * Array of message actions.
     */
    actions?: Array<Action>
    /**
     * The payload of a [reply button](https://docs.smooch.io/guide/structured-messages/#reply-buttons) response message.
     */
    payload?: string
}

export type TextMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The text content of the message. Required unless `actions`, `htmlText` or `markdownText` is provided.
     */
    text?: string
    htmlText?: HtmlText
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    markdownText?: MarkdownText
    /**
     * Array of message actions.
     */
    actions?: Array<Action>
    /**
     * The payload of a [reply button](https://docs.smooch.io/guide/structured-messages/#reply-buttons) response message.
     */
    payload?: string
}

export type ActionSubset =
    | ({
          type: 'buy'
      } & Buy)
    | ({
          type: 'link'
      } & Link)
    | ({
          type: 'postback'
      } & Postback)
    | ({
          type: 'webview'
      } & Webview)

export type Item = {
    /**
     * The title of the item.
     */
    title: string
    /**
     * The description of the item.
     */
    description?: string
    /**
     * The image url attached to the item.
     */
    mediaUrl?: string
    /**
     * The MIME type for any image attached in the mediaUrl.
     */
    mediaType?: string
    /**
     * An optional description of the media for accessibility purposes. The field will be saved by default with the file name as the value.
     */
    altText?: string
    /**
     * The size of the image.
     */
    size?: 'compact' | 'large'
    /**
     * An array of objects representing the actions associated with the item.
     */
    actions: Array<ActionSubset>
    metadata?: Metadata
}

/**
 * Carousel messages are a horizontally scrollable set of items that may each contain text, an image, and message actions. Not all messaging channels fully support carousel messages; currently only Facebook Messenger, LINE, Telegram, Viber, the Web Messenger, the Android SDK and the iOS SDK cover the full functionality. For all other platforms a carousel message is rendered as raw text. The raw text fallback does not include any images or postback message actions.
 */
export type CarouselMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The fallback text message used when carousel messages are not supported by the channel.
     */
    readonly text?: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * An array of objects representing the items associated with the message. Only present in carousel and list type messages.
     */
    items: Array<Item>
    /**
     * Settings to adjust the carousel layout.
     */
    displaySettings?: {
        /**
         * Specifies how to display all carousel images. Valid values are horizontal (default) and square. Only supported in Facebook Messenger, Web Messenger, Android SDK and iOS SDK carousels.
         */
        imageAspectRatio?: 'horizontal' | 'square'
    }
}

/**
 * Carousel messages are a horizontally scrollable set of items that may each contain text, an image, and message actions. Not all messaging channels fully support carousel messages; currently only Facebook Messenger, LINE, Telegram, Viber, the Web Messenger, the Android SDK and the iOS SDK cover the full functionality. For all other platforms a carousel message is rendered as raw text. The raw text fallback does not include any images or postback message actions.
 */
export type CarouselMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * An array of objects representing the items associated with the message. Only present in carousel and list type messages.
     */
    items: Array<Item>
    /**
     * Settings to adjust the carousel layout.
     */
    displaySettings?: {
        /**
         * Specifies how to display all carousel images. Valid values are horizontal (default) and square. Only supported in Facebook Messenger, Web Messenger, Android SDK and iOS SDK carousels.
         */
        imageAspectRatio?: 'horizontal' | 'square'
    }
}

export type FileMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The URL for media, such as an image, attached to the message.
     * <aside class="notice">Note that for private attachments an authorization header is required to access the mediaUrl. See [configuring private attachments for messaging](https://developer.zendesk.com/documentation/zendesk-web-widget-sdks/messaging_private_attachments/) guide for more details.</aside>
     *
     */
    mediaUrl: string
    /**
     * The size of the media.
     */
    readonly mediaSize?: number
    /**
     * The media type of the file.
     */
    readonly mediaType?: string
    /**
     * An optional description of the file for accessibility purposes. The field will be saved by default with the file name as the value.
     */
    altText?: string
    /**
     * The text content of the message.
     */
    text?: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    htmlText?: HtmlText
    /**
     * An identifier used by Sunshine Conversations for internal purposes.
     */
    attachmentId?: string
}

export type FileMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The URL for media, such as an image, attached to the message.
     * <aside class="notice">Note that for private attachments an authorization header is required to access the mediaUrl. See [configuring private attachments for messaging](https://developer.zendesk.com/documentation/zendesk-web-widget-sdks/messaging_private_attachments/) guide for more details.</aside>
     *
     */
    mediaUrl: string
    /**
     * An optional description of the file for accessibility purposes. The field will be saved by default with the file name as the value.
     */
    altText?: string
    /**
     * The text content of the message.
     */
    text?: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    htmlText?: HtmlText
    markdownText?: MarkdownText
    /**
     * An identifier used by Sunshine Conversations for internal purposes.
     */
    attachmentId?: string
}

export type Field = {
    /**
     * The field type.
     */
    type: 'email' | 'select' | 'text'
    /**
     * The name of the field. Must be unique per form or formResponse.
     */
    name: string
    /**
     * The label of the field. What the field is displayed as on Web Messenger.
     */
    label: string
    /**
     * Specifies the response for a text field.
     */
    text?: string
    /**
     * Specifies the response for a email field.
     */
    email?: string
    /**
     * Array of objects representing the response for a field of type select. Form and formResponse messages only.
     */
    select?: Array<{
        [key: string]: unknown
    }>
}

/**
 * Array of objects representing options for a field of type select.
 */
export type FormOptions = Array<{
    /**
     * The label of the option. What the option is displayed as on Web Messenger.
     */
    label?: string
    /**
     * The name of the field. Must be unique per field.
     */
    name?: string
}>

export type FormMessageField = Field & {
    /**
     * Placeholder text for the field. Form message only.
     */
    placeholder?: string
    /**
     * The minimum allowed length for the response for a field of type text. Form message only.
     */
    minSize?: number
    /**
     * The maximum allowed length for the response for a field of type text. Form message only.
     */
    maxSize?: number
    options?: FormOptions
}

/**
 * A form type message without text or actions. Only supported in the Web SDK.
 */
export type FormMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * Flag which states whether the form is submitted.
     */
    readonly submitted?: boolean
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation..
     */
    blockChatInput?: boolean
    /**
     * An array of objects representing fields associated with the message. Only present in form and formResponse messages.
     */
    fields: Array<FormMessageField>
}

/**
 * A form type message without text or actions. Only supported in the Web SDK.
 */
export type FormMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation..
     */
    blockChatInput?: boolean
    /**
     * An array of objects representing fields associated with the message. Only present in form and formResponse messages.
     */
    fields: Array<FormMessageField>
}

export type FormResponseMessageFieldReadable = Field

export type FormResponseMessageFieldWritable = Field & {
    /**
     * The messageId for the form that this response belongs to.
     */
    quotedMessageId?: string
}

/**
 * A formResponse type message is a response to a form type message. formResponse type messages are only supported as responses to form messages on Web Messenger and cannot be sent via the API.
 */
export type FormResponseMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * Array of field objects that contain the submitted fields.
     */
    fields: Array<FormResponseMessageFieldReadable>
    /**
     * A string containing the `label: value` of all fields, each separated by a newline character.
     */
    readonly textFallback?: string
}

/**
 * A formResponse type message is a response to a form type message. formResponse type messages are only supported as responses to form messages on Web Messenger and cannot be sent via the API.
 */
export type FormResponseMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * Array of field objects that contain the submitted fields.
     */
    fields: Array<FormResponseMessageFieldWritable>
}

export type ImageMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The URL for media, such as an image, attached to the message.
     * <aside class="notice">Note that for private attachments an authorization header is required to access the mediaUrl. See [configuring private attachments for messaging](https://developer.zendesk.com/documentation/zendesk-web-widget-sdks/messaging_private_attachments/) guide for more details.</aside>
     *
     */
    mediaUrl: string
    /**
     * The type of media.
     */
    readonly mediaType?: string
    /**
     * The size of the media in bytes.
     */
    readonly mediaSize?: number
    /**
     * An optional description of the image for accessibility purposes. The field will be saved by default with the file name as the value.
     */
    altText?: string
    /**
     * The text content of the message.
     */
    text?: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    htmlText?: HtmlText
    /**
     * Array of message actions.
     */
    actions?: Array<Action>
    /**
     * An identifier used by Sunshine Conversations for internal purposes.
     */
    attachmentId?: string
}

export type ImageMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The URL for media, such as an image, attached to the message.
     * <aside class="notice">Note that for private attachments an authorization header is required to access the mediaUrl. See [configuring private attachments for messaging](https://developer.zendesk.com/documentation/zendesk-web-widget-sdks/messaging_private_attachments/) guide for more details.</aside>
     *
     */
    mediaUrl: string
    /**
     * An optional description of the image for accessibility purposes. The field will be saved by default with the file name as the value.
     */
    altText?: string
    /**
     * The text content of the message.
     */
    text?: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    htmlText?: HtmlText
    markdownText?: MarkdownText
    /**
     * Array of message actions.
     */
    actions?: Array<Action>
    /**
     * An identifier used by Sunshine Conversations for internal purposes.
     */
    attachmentId?: string
}

/**
 * ListMessage
 * List messages are a vertically scrollable set of items that may each contain text, an image, and message actions. Not all messaging channels fully support list messages.
 * * Facebook Messenger and WeChat have native support.
 * * For LINE and our Android, iOS and Web SDK, Sunshine Conversations converts list messages to carousel.
 * * On WhatsApp, Telegram and Twitter, Sunshine Conversations converts list messages to multiple rich messages.
 * * On all other platforms, Sunshine Conversations converts list messages to raw text.
 *
 */
export type ListMessage = {
    /**
     * The type of message.
     */
    type: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * An array of objects representing the items associated with the message. Only present in carousel and list type messages.
     */
    items: Array<Item>
    /**
     * An array of objects representing the actions associated with the message. The array length is limited by the third party channel.
     */
    actions?: Array<ActionSubset>
}

/**
 * A location type message includes the coordinates (latitude and longitude) of a location and an optional location object which can include the name and address of the location. Typically sent in response to a Location Request.
 */
export type LocationMessageReadable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * The fallback text message used when location messages are not supported by the channel.
     */
    readonly text?: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * The coordinates of the location.
     */
    coordinates: {
        /**
         * Global latitude.
         */
        lat: number
        /**
         * Global longitude.
         */
        long: number
    }
    /**
     * Information about the location.
     */
    location?: {
        /**
         * A string representing the address of the location.
         */
        address?: string
        /**
         * A string representing the name of the location.
         */
        name?: string
    }
}

/**
 * A location type message includes the coordinates (latitude and longitude) of a location and an optional location object which can include the name and address of the location. Typically sent in response to a Location Request.
 */
export type LocationMessageWritable = {
    /**
     * The type of message.
     */
    type: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * The coordinates of the location.
     */
    coordinates: {
        /**
         * Global latitude.
         */
        lat: number
        /**
         * Global longitude.
         */
        long: number
    }
    /**
     * Information about the location.
     */
    location?: {
        /**
         * A string representing the address of the location.
         */
        address?: string
        /**
         * A string representing the name of the location.
         */
        name?: string
    }
}

export type TemplateMessage = {
    /**
     * The type of message.
     */
    type: string
    /**
     * When set to true, the chat input will be disabled on supported client implementations when the message is the most recent one in the history. Can be used for guided flows or to temporarily disable the user's ability to send messages in the conversation.
     */
    blockChatInput?: boolean
    /**
     * The whatsapp template message to send. For more information, consult the [guide](https://docs.smooch.io/guide/whatsapp#sending-message-templates). `schema` must be set to `whatsapp`.
     */
    template: {
        [key: string]: unknown
    }
}

export type ContentReadable =
    | ({
          type: 'text'
      } & TextMessageReadable)
    | ({
          type: 'carousel'
      } & CarouselMessageReadable)
    | ({
          type: 'file'
      } & FileMessageReadable)
    | ({
          type: 'form'
      } & FormMessageReadable)
    | ({
          type: 'formResponse'
      } & FormResponseMessageReadable)
    | ({
          type: 'image'
      } & ImageMessageReadable)
    | ({
          type: 'list'
      } & ListMessage)
    | ({
          type: 'location'
      } & LocationMessageReadable)
    | ({
          type: 'template'
      } & TemplateMessage)

export type ContentWritable =
    | ({
          type: 'text'
      } & TextMessageWritable)
    | ({
          type: 'carousel'
      } & CarouselMessageWritable)
    | ({
          type: 'file'
      } & FileMessageWritable)
    | ({
          type: 'form'
      } & FormMessageWritable)
    | ({
          type: 'formResponse'
      } & FormResponseMessageWritable)
    | ({
          type: 'image'
      } & ImageMessageWritable)
    | ({
          type: 'list'
      } & ListMessage)
    | ({
          type: 'location'
      } & LocationMessageWritable)
    | ({
          type: 'template'
      } & TemplateMessage)

export type Client = {
    /**
     * The unique ID of the client.
     */
    id?: string
    type?: ClientType
    /**
     * The client status. Indicates if the client is able to receive messages or not. Can be pending, inactive, active, or blocked.
     */
    status?: 'active' | 'blocked' | 'inactive' | 'pending'
    /**
     * The ID of the integration that the client was created for. Unused for clients of type sdk, as they incorporate multiple integrations.
     */
    integrationId?: string | null
    /**
     * The ID of the user on an external channel. For example, the user’s phone number for Twilio, or their page-scoped user ID for Facebook Messenger. Applies only to non-SDK clients.
     */
    externalId?: string | null
    /**
     * A datetime string with the format `YYYY-MM-DDThh:mm:ss.SSSZ` representing the last time the user interacted with this client.
     */
    lastSeen?: string | null
    /**
     * A timestamp signifying when the client was added to the user. Formatted as `YYYY-MM-DDThh:mm:ss.SSSZ`.
     */
    linkedAt?: string | null
    /**
     * The user's display name on the channel.
     */
    displayName?: string | null
    /**
     * The URL for the user's avatar on the channel.
     */
    avatarUrl?: string | null
    /**
     * A flat curated object with properties that vary for each client platform. All keys are optional and not guaranteed to be available.
     */
    info?: {
        [key: string]: unknown
    } | null
    /**
     * An object with raw properties that vary for each client platform. All keys are optional and not guaranteed to be available.
     */
    raw?: {
        [key: string]: unknown
    } | null
}

export type Device = {
    /**
     * The unique ID of the device.
     */
    id?: string
    /**
     * The type of integration that the device represents.
     */
    type?: 'android' | 'ios' | 'web'
    /**
     * A unique identifier for the device, generated client-side by the SDK.
     */
    guid?: string
    /**
     * The id of the client to which this device is associated.
     */
    clientId?: string
    /**
     * The device status. Indicates if the device will receive push notifications or not.
     */
    status?: 'active' | 'inactive'
    /**
     * The ID of the integration that the device was created for.
     */
    integrationId?: string
    /**
     * A datetime string with the format YYYY-MM-DDThh:mm:ss.SSSZ representing the last time the user interacted with this device.
     */
    lastSeen?: string
    /**
     * The token used for push notifications on Android and iOS devices.
     */
    pushNotificationToken?: string | null
    /**
     * A flat curated object with properties that vary for each SDK platform. All keys are optional and not guaranteed to be available.
     */
    info?: {
        [key: string]: unknown
    } | null
    /**
     * Version of the mobile app in which the SDK is embedded. Not applicable for devices of type web.
     */
    appVersion?: string | null
}

/**
 * The source of the message.
 */
export type Source = {
    /**
     * An identifier for the channel from which a message originated. May include one of api, sdk, messenger, or any number of other channels.
     */
    type: string
    /**
     * Identifier indicating which integration the message was sent from. For user messages only.
     */
    integrationId?: string | null
    /**
     * Message identifier assigned by the originating channel.
     */
    originalMessageId?: string | null
    /**
     * A datetime string with the format `YYYY-MM-DDThh:mm:ss.SSSZ` representing when the third party channel received the message.
     */
    originalMessageTimestamp?: string | null
    /**
     * The client from which the user authored the message or activity, if applicable. This field is not applicable in API responses, it is used only in webhook payloads if the `includeFullSource` option is enabled.
     */
    client?: Client | null
    /**
     * The device from which the user authored the message or activity, if applicable. This field is not applicable in API responses, it is used only in webhook payloads if the `includeFullSource` option is enabled.
     */
    device?: Device | null
}

export type MessageReadable = {
    /**
     * The unique ID of the message.
     */
    id?: string
    /**
     * A datetime string with the format `YYYY-MM-DDThh:mm:ss.SSSZ` representing when Sunshine Conversations received the message.
     */
    received?: string
    author?: AuthorReadable
    /**
     * Details of the system activity that generated this message. This field is used when actions taken by the system generate a persisted message to notify the user or agent of an event that occurred. For example, when a user's Ticket gets closed. This property applies only to informational text messages generated via system events.
     */
    activity?: ActivityMessageReadable & {
        type?: 'message'
    }
    /**
     * The content of the message.
     */
    content?: ContentReadable & {
        type?: 'message'
    }
    source?: Source
    /**
     * The quoted message is currently only available for WhatsApp and Web Messenger `formResponse` messages.
     */
    quotedMessage?:
        | (QuotedMessageReadable & {
              type?: 'message'
          })
        | null
    metadata?: Metadata | null
    /**
     * true if the message serves as a placeholder for one that has been deleted.
     */
    deleted?: boolean | null
}

export type MessageWritable = {
    /**
     * The unique ID of the message.
     */
    id?: string
    /**
     * A datetime string with the format `YYYY-MM-DDThh:mm:ss.SSSZ` representing when Sunshine Conversations received the message.
     */
    received?: string
    author?: AuthorWritable
    /**
     * Details of the system activity that generated this message. This field is used when actions taken by the system generate a persisted message to notify the user or agent of an event that occurred. For example, when a user's Ticket gets closed. This property applies only to informational text messages generated via system events.
     */
    activity?: ActivityMessageWritable & {
        type?: 'message'
    }
    /**
     * The content of the message.
     */
    content?: ContentWritable & {
        type?: 'message'
    }
    source?: Source
    /**
     * The quoted message is currently only available for WhatsApp and Web Messenger `formResponse` messages.
     */
    quotedMessage?:
        | (QuotedMessageWritable & {
              type?: 'message'
          })
        | null
    metadata?: Metadata | null
    /**
     * true if the message serves as a placeholder for one that has been deleted.
     */
    deleted?: boolean | null
}

/**
 * QuotedMessageMessage
 */
export type QuotedMessageMessageReadable = {
    /**
     * The type of quotedMessage - a complete Sunshine Conversations message is provided.
     */
    type: string
    message?: MessageReadable
}

/**
 * QuotedMessageMessage
 */
export type QuotedMessageMessageWritable = {
    /**
     * The type of quotedMessage - a complete Sunshine Conversations message is provided.
     */
    type: string
    message?: MessageWritable
}

/**
 * QuotedMessageExternalMessageId
 */
export type QuotedMessageExternalMessageId = {
    /**
     * The type of quotedMessage - `externalMessageId` if no Sunshine Conversations message matched the quoted message.
     */
    type: string
    /**
     * The external message Id of the quoted message.
     */
    externalMessageId?: string
}

export type QuotedMessageReadable =
    | ({
          type: 'message'
      } & QuotedMessageMessageReadable)
    | ({
          type: 'externalMessageId'
      } & QuotedMessageExternalMessageId)

export type QuotedMessageWritable =
    | ({
          type: 'message'
      } & QuotedMessageMessageWritable)
    | ({
          type: 'externalMessageId'
      } & QuotedMessageExternalMessageId)

/**
 * MessageListResponse
 */
export type MessageListResponseReadable = {
    /**
     * List of returned messages.
     */
    messages?: Array<MessageReadable>
    meta?: Meta
    links?: Links
}

/**
 * MessageListResponse
 */
export type MessageListResponseWritable = {
    /**
     * List of returned messages.
     */
    messages?: Array<MessageWritable>
    meta?: Meta
    links?: Links
}

/**
 * The destination of the message, in the case of [channel targeting](https://docs.smooch.io/guide/sending-messages/#targeting-a-specific-channel) or sending [silent messages](https://docs.smooch.io/guide/sending-messages/#silent-messages). Only
 * applicable if the author role is `business` and the conversation is of type
 * `personal`.
 *
 */
export type Destination =
    | {
          /**
           * The id of the integration to deliver the message to. Will return an error if
           * the integration does not exist or if the user does not have a client for the
           * integration attached to the conversation.
           *
           */
          integrationId?: string
      }
    | {
          /**
           * The type of the integration to deliver the message to. Can be set to `none` if sending a [silent message](https://docs.smooch.io/guide/sending-messages/#silent-messages). Will return an error
           * if the user does not have a client of that type attached to the
           * conversation.
           *
           */
          integrationType?: string
      }

/**
 * The exact payload to send to the channel.
 */
export type AppleMessageOverridePayload = {
    payload?: {
        [key: string]: unknown
    }
    /**
     * List of capabilities needed for the override message to be received by the end user.
     *
     * `LIST` : for list picker;
     * `TIME` : for time picker;
     * `FORM` : for form;
     * `QUICK` : for quick reply;
     * `AUTH2` : for authentication
     *
     */
    withCapabilities?: Array<'LIST' | 'TIME' | 'FORM' | 'QUICK' | 'AUTH2'>
}

/**
 * The exact payload to send to the channel.
 */
export type MessageOverridePayload = {
    payload?: {
        [key: string]: unknown
    }
}

/**
 * A raw payload containing a message that is sent directly to a channel. Messages for [Apple Messages for Business](https://docs.smooch.io/guide/apple-messages-for-business/#passthrough-api), [Line](https://docs.smooch.io/guide/line/#passthrough-api), [Messenger](https://docs.smooch.io/guide/facebook-messenger/#passthrough-api), [Whatsapp](https://docs.smooch.io/guide/whatsapp/#passthrough-api) channels are supported.
 */
export type MessageOverride =
    | {
          apple?: AppleMessageOverridePayload
      }
    | {
          line?: MessageOverridePayload
      }
    | {
          messenger?: MessageOverridePayload
      }
    | {
          whatsapp?: MessageOverridePayload
      }

export type MessagePostReadable = {
    /**
     * The author of the message.
     */
    author: AuthorReadable
    /**
     * The content of the message.
     */
    content: ContentReadable & {
        type?: 'messagePost'
    }
    destination?: Destination
    metadata?: Metadata
    override?: MessageOverride
    /**
     * When `schema` is set to `"whatsapp"`, the `content` key is expected to conform to the [native WhatsApp schema](https://developers.facebook.com/docs/whatsapp/api/messages/message-templates) for sending message templates.
     * For more details, consult the documentation for [sending message templates on WhatsApp](https://docs.smooch.io/guide/whatsapp/#sending-message-templates).
     *
     */
    schema?: string
}

export type MessagePostWritable = {
    /**
     * The author of the message.
     */
    author: AuthorWritable
    /**
     * The content of the message.
     */
    content: ContentWritable & {
        type?: 'messagePost'
    }
    destination?: Destination
    metadata?: Metadata
    override?: MessageOverride
    /**
     * When `schema` is set to `"whatsapp"`, the `content` key is expected to conform to the [native WhatsApp schema](https://developers.facebook.com/docs/whatsapp/api/messages/message-templates) for sending message templates.
     * For more details, consult the documentation for [sending message templates on WhatsApp](https://docs.smooch.io/guide/whatsapp/#sending-message-templates).
     *
     */
    schema?: string
}

/**
 * The created messages. A single request may produce multiple messages when the shorthand syntax is used to send a template message with leading text.
 */
export type MessagePostResponseReadable = {
    messages?: Array<MessageReadable>
}

/**
 * The created messages. A single request may produce multiple messages when the shorthand syntax is used to send a template message with leading text.
 */
export type MessagePostResponseWritable = {
    messages?: Array<MessageWritable>
}

export type ActivityTypes = {
    /**
     * If the author type is `user`, only `conversation:read` is supported.
     */
    type?: 'conversation:read' | 'typing:start' | 'typing:stop'
}

export type ActivityPostReadable = {
    /**
     * The author of the activity.
     */
    author: AuthorReadable
} & ActivityTypes

export type ActivityPostWritable = {
    /**
     * The author of the activity.
     */
    author: AuthorWritable
} & ActivityTypes

export type AcceptControlBody = {
    /**
     * Flat object containing custom properties. Strings, numbers and booleans are the only supported format that can be passed to metadata. The metadata is limited to 4KB in size. The metadata object will be included in the `switchboard:acceptControl` and `switchboard:acceptControl:failure` webhooks.
     */
    metadata?: Metadata
}

export type OfferControlBody = {
    /**
     * The id or the name of the switchboard integration that will become pending. Also supports the `next` keyword to offer control to the next switchboard integration designated in the switchboard hierarchy configuration. This cannot match the active switchboard integration.
     */
    switchboardIntegration: string
    /**
     * Flat object containing custom properties. Strings, numbers and booleans are the only supported format that can be passed to metadata. The metadata is limited to 4KB in size. The metadata object will be included in the `switchboard:offerControl` and `switchboard:offerControl:failure` webhooks.
     */
    metadata?: Metadata
}

export type PassControlBody = {
    /**
     * The id or the name of the switchboard integration that will become active. May also use the `next` keyword to transfer control to the next switchboard integration designated in the switchboard hierarchy configuration
     */
    switchboardIntegration: string
    /**
     * Flat object containing custom properties. Strings, numbers and booleans are the only supported format that can be passed to metadata. The metadata is limited to 4KB in size. The metadata object will be included in the `switchboard:passControl` webhook.
     */
    metadata?: Metadata
}

export type DownloadMessageRefBody = {
    /**
     * The id of the user.
     */
    userId: string
    /**
     * The message ref returned by Apple.
     */
    apple?: {
        /**
         * interactiveDataRef can be found in the passthrough webhook.
         */
        interactiveDataRef: {
            url: string
            bid: string
            key: string
            signature: string
            owner: string
        }
    }
}

/**
 * The integration.
 */
export type IntegrationReadable = {
    /**
     * The unique ID of the integration.
     */
    readonly id?: string
    type: string
    status?: Status
    /**
     * A human-friendly name used to identify the integration.
     */
    displayName?: string | null
}

/**
 * The integration.
 */
export type IntegrationWritable = {
    type: string
    status?: Status
    /**
     * A human-friendly name used to identify the integration.
     */
    displayName?: string | null
}

/**
 * Default Responder ID
 */
export type DefaultResponderId = {
    /**
     * The default responder ID for the integration. This is the ID of the responder that will be used to send messages to the user.
     * For more information, refer to <a href="https://docs.smooch.io/guide/switchboard/#per-channel-default-responder">Per-channel default responder</a> guide.
     *
     */
    defaultResponderId?: string | null
}

/**
 * Default Responder
 */
export type DefaultResponderReadable = {
    /**
     * The default responder for the integration. This is the responder that will be used to send messages to the user.
     * For more information, refer to the <a href="https://docs.smooch.io/guide/switchboard/#per-channel-default-responder">Per-channel default responder</a> guide.
     *
     */
    readonly defaultResponder?: {
        /**
         * The name of the switchboard integration.
         */
        name?: string
        /**
         * The unique ID of the integration.
         */
        integrationId?: string
        /**
         * The type of the integration.
         */
        integrationType?: string
        /**
         * Indicates whether the switchboard should deliver standby events.
         */
        deliverStandbyEvents?: boolean
        /**
         * The unique ID of the next switchboard integration.
         */
        nextSwitchboardIntegrationId?: string | null
        /**
         * The number of messages to keep in the message history.
         */
        messageHistoryCount?: number
        /**
         * Indicates whether the default responder is inherited from the switchboard's global config or not. Returns `false` if a per-channel responder override has been set for this integration, and `true` otherwise.
         */
        inherited?: boolean
    } | null
}

export type DefaultResponderWritable = DefaultResponderReadable

export type AndroidReadable = IntegrationReadable & {
    type: 'android'
} & {
    /**
     * <aside class="notice">Firebase Cloud Messaging has deprecated its legacy APIs for HTTP and XMPP. Legacy credentials <code>serverKey</code> and <code>senderId</code> will stop working as of June 2024 and must be replaced with OAuth 2.0 access token based credentials.</aside>
     *
     * To configure an android integration, first visit the [Firebase Console](https://console.firebase.google.com/).
     * Generate a private key from the Service accounts tab in the settings.
     * Copy the `project_id`, `client_email` and `private_key` from the generated JSON file and call the create integrations endpoint with this data.
     *
     */
    type?: string
    /**
     * Your sender id from the fcm console.
     * @deprecated
     */
    senderId?: string | null
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the android integration.
     */
    canUserCreateMoreConversations?: boolean
    /**
     * Allows users to send attachments. By default, the setting is set to true. This setting can only be configured in Zendesk Admin Center.
     *
     */
    readonly attachmentsEnabled?: boolean
} & DefaultResponderReadable

export type AndroidWritable = IntegrationWritable & {
    type: 'android'
} & {
    /**
     * <aside class="notice">Firebase Cloud Messaging has deprecated its legacy APIs for HTTP and XMPP. Legacy credentials <code>serverKey</code> and <code>senderId</code> will stop working as of June 2024 and must be replaced with OAuth 2.0 access token based credentials.</aside>
     *
     * To configure an android integration, first visit the [Firebase Console](https://console.firebase.google.com/).
     * Generate a private key from the Service accounts tab in the settings.
     * Copy the `project_id`, `client_email` and `private_key` from the generated JSON file and call the create integrations endpoint with this data.
     *
     */
    type?: string
    /**
     * Your project ID from your generated private key file.
     */
    projectId?: string | null
    /**
     * Your client email from your generated private key file.
     */
    clientEmail?: string | null
    /**
     * Your private key from your generated private key file.
     */
    privateKey?: string | null
    /**
     * Your server key from the fcm console.
     * @deprecated
     */
    serverKey?: string | null
    /**
     * Your sender id from the fcm console.
     * @deprecated
     */
    senderId?: string | null
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the android integration.
     */
    canUserCreateMoreConversations?: boolean
} & DefaultResponderId &
    DefaultResponderWritable

export type AppleReadable = IntegrationReadable & {
    type: 'apple'
} & {
    /**
     * To configure an Apple Messages for Business integration, acquire the required information and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Apple Messages for Business ID.
     */
    businessId: string
    /**
     * Your Messaging Service Provider ID.
     */
    mspId: string
    /**
     * A secret used to create the state value when sending Apple authentication 2.0 messages
     */
    authenticationMessageSecret?: string
} & DefaultResponderReadable

export type AppleWritable = IntegrationWritable & {
    type: 'apple'
} & {
    /**
     * To configure an Apple Messages for Business integration, acquire the required information and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Apple Messages for Business ID.
     */
    businessId: string
    /**
     * Your Apple API secret which is tied to your Messaging Service Provider.
     */
    apiSecret: string
    /**
     * Your Messaging Service Provider ID.
     */
    mspId: string
    /**
     * A secret used to create the state value when sending Apple authentication 2.0 messages
     */
    authenticationMessageSecret?: string
} & DefaultResponderId &
    DefaultResponderWritable

/**
 * URL to be called when the webhook is triggered.
 */
export type Target = string

/**
 * An array of triggers the integration is subscribed to. This property is case sensitive. [More details](https://docs.smooch.io/rest/#section/Webhook-Triggers).
 */
export type Triggers = Array<string>

/**
 * A boolean specifying whether webhook payloads should include the complete user schema for events involving a specific user.
 */
export type IncludeFullUser = boolean

/**
 * A boolean specifying whether webhook payloads should include the client and device object (when applicable).
 */
export type IncludeFullSource = boolean

export type WebhookReadable = {
    /**
     * A unique identifier for the webhook.
     */
    readonly id?: string
    /**
     * Schema version of the payload delivered to this webhook. Can be `v1`, `v1.1` or `v2`.
     */
    readonly version?: string
    target: Target
    triggers: Triggers
    /**
     * Webhook secret, used to verify the origin of incoming requests.
     */
    secret?: string
    includeFullUser?: IncludeFullUser
    includeFullSource?: IncludeFullSource
}

export type WebhookWritable = {
    target: Target
    triggers: Triggers
    /**
     * Webhook secret, used to verify the origin of incoming requests.
     */
    secret?: string
    includeFullUser?: IncludeFullUser
    includeFullSource?: IncludeFullSource
}

export type CustomReadable = IntegrationReadable & {
    type: 'custom'
} & {
    /**
     * To configure a custom integration you need to setup a webhook with a set of triggers and target.
     *
     */
    type?: string
    /**
     * An array of webhooks associated with the custom integration.
     */
    webhooks: [WebhookReadable]
}

export type CustomWritable = IntegrationWritable & {
    type: 'custom'
} & {
    /**
     * To configure a custom integration you need to setup a webhook with a set of triggers and target.
     *
     */
    type?: string
    /**
     * An array of webhooks associated with the custom integration.
     */
    webhooks: [WebhookWritable]
}

export type InstagramReadable = IntegrationReadable & {
    type: 'instagram'
} & {
    /**
     * Instagram Direct setup steps:
     * - Take note of your Facebook app ID and secret (apps can be created at [developer.facebook.com](https://developer.facebook.com));
     * - The Facebook app must have been submitted to Meta for app review with the "pages_manage_metadata" (to retrieve Page Access Tokens for the Pages and apps that the app user administers and to set a webhook), "instagram_basic", and "instagram_manage_messages" (to retrieve basic Instagram account information and send messages) permissions.
     * - In order to integrate an Instagram Direct app, you must acquire a Page Access Token from your user. Once you have acquired a page access token from your user, call the Create Integration endpoint with your app secret and ID and the user’s page access token.
     *
     */
    type?: string
    /**
     * Your Facebook App ID.
     */
    appId: string
    /**
     * Your Instagram Business account name
     */
    readonly businessName?: string
    /**
     * Your Instagram Business unique username
     */
    readonly businessUsername?: string
    /**
     * The ID of the Facebook Page linked to your Instagram Business account
     */
    readonly pageId?: string
    /**
     * The ID of the Instagram Business account
     */
    readonly businessId?: string
    /**
     * The Facebook user's username. This is returned when integrating through the Dashboard
     */
    readonly username?: string
    /**
     * The Facebook user's user ID. This is returned when integrating through the Dashboard
     */
    readonly userId?: string
} & DefaultResponderReadable

export type InstagramWritable = IntegrationWritable & {
    type: 'instagram'
} & {
    /**
     * Instagram Direct setup steps:
     * - Take note of your Facebook app ID and secret (apps can be created at [developer.facebook.com](https://developer.facebook.com));
     * - The Facebook app must have been submitted to Meta for app review with the "pages_manage_metadata" (to retrieve Page Access Tokens for the Pages and apps that the app user administers and to set a webhook), "instagram_basic", and "instagram_manage_messages" (to retrieve basic Instagram account information and send messages) permissions.
     * - In order to integrate an Instagram Direct app, you must acquire a Page Access Token from your user. Once you have acquired a page access token from your user, call the Create Integration endpoint with your app secret and ID and the user’s page access token.
     *
     */
    type?: string
    /**
     * The Facebook Page Access Token of the Facebook page that is linked to your Instagram account.
     */
    pageAccessToken: string | null
    /**
     * Your Facebook App ID.
     */
    appId: string
    /**
     * Your Facebook App secret.
     */
    appSecret: string | null
} & DefaultResponderId &
    DefaultResponderWritable

export type IosReadable = IntegrationReadable & {
    type: 'ios'
} & {
    /**
     * To configure an ios integration, call the create integration endpoint with a base64 encoded Apple Push Notification certificate from the [Apple Developer Portal](https://developer.apple.com/).
     *
     */
    type?: string
    /**
     * The APN environment to connect to (Production, if true, or Sandbox). Defaults to value inferred from certificate if not specified.
     */
    production?: boolean
    /**
     * Use the unread count of the conversation as the application badge.
     */
    autoUpdateBadge?: boolean
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the iOS integration.
     */
    canUserCreateMoreConversations?: boolean
    /**
     * Allows users to send attachments. By default, the setting is set to true. This setting can only be configured in Zendesk Admin Center.
     *
     */
    readonly attachmentsEnabled?: boolean
} & DefaultResponderReadable

export type IosWritable = IntegrationWritable & {
    type: 'ios'
} & {
    /**
     * To configure an ios integration, call the create integration endpoint with a base64 encoded Apple Push Notification certificate from the [Apple Developer Portal](https://developer.apple.com/).
     *
     */
    type?: string
    /**
     * The binary of your APN certificate base64 encoded. To base64 encode your certificate you can use this command in the terminal:
     * `openssl base64 -in YOUR_CERTIFICATE.p12 | tr -d '\n'`
     *
     */
    certificate?: string | null
    /**
     * The password for your APN certificate.
     */
    password?: string
    /**
     * The APN environment to connect to (Production, if true, or Sandbox). Defaults to value inferred from certificate if not specified.
     */
    production?: boolean
    /**
     * Use the unread count of the conversation as the application badge.
     */
    autoUpdateBadge?: boolean
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the iOS integration.
     */
    canUserCreateMoreConversations?: boolean
} & DefaultResponderId &
    DefaultResponderWritable

export type LineReadable = IntegrationReadable & {
    type: 'line'
} & {
    /**
     * For LINE, each of your customers will need to manually configure a webhook in their LINE configuration page that will point to Sunshine Conversations servers. You must instruct your customers how to configure this manually on their LINE bot page.
     * Once you’ve acquired all the required information, call the Create Integration endpoint.
     * Then, using the returned integration _id, your customer must set the Callback URL field in their LINE Business Center page.
     * The URL should look like the following: `https://app.smooch.io:443/api/line/webhooks/{appId}/{integrationId}`.
     *
     */
    type?: string
    /**
     * LINE Channel ID. Can be omitted along with `channelSecret` to integrate LINE to setup a webhook before receiving the `channelId` and `channelSecret` back from LINE.
     */
    channelId?: string
    /**
     * LINE Channel Secret. Can be omitted along with `channelId` to integrate LINE to setup a webhook before receiving the `channelId` and `channelSecret` back from LINE.
     */
    channelSecret?: string
    /**
     * LINE Channel Access Token.
     */
    channelAccessToken?: string
    /**
     * LINE Service Code.
     */
    serviceCode?: string
    /**
     * LINE Switcher Secret.
     */
    switcherSecret?: string
    /**
     * URL provided by LINE in the [Developer Console](https://developers.line.biz/console/).
     */
    qrCodeUrl?: string
    /**
     * LINE Basic ID. Is automatically set when qrCodeUrl is updated.
     */
    readonly lineId?: string
} & DefaultResponderReadable

export type LineWritable = IntegrationWritable & {
    type: 'line'
} & {
    /**
     * For LINE, each of your customers will need to manually configure a webhook in their LINE configuration page that will point to Sunshine Conversations servers. You must instruct your customers how to configure this manually on their LINE bot page.
     * Once you’ve acquired all the required information, call the Create Integration endpoint.
     * Then, using the returned integration _id, your customer must set the Callback URL field in their LINE Business Center page.
     * The URL should look like the following: `https://app.smooch.io:443/api/line/webhooks/{appId}/{integrationId}`.
     *
     */
    type?: string
    /**
     * LINE Channel ID. Can be omitted along with `channelSecret` to integrate LINE to setup a webhook before receiving the `channelId` and `channelSecret` back from LINE.
     */
    channelId?: string
    /**
     * LINE Channel Secret. Can be omitted along with `channelId` to integrate LINE to setup a webhook before receiving the `channelId` and `channelSecret` back from LINE.
     */
    channelSecret?: string
    /**
     * LINE Channel Access Token.
     */
    channelAccessToken?: string
    /**
     * LINE Service Code.
     */
    serviceCode?: string
    /**
     * LINE Switcher Secret.
     */
    switcherSecret?: string
    /**
     * URL provided by LINE in the [Developer Console](https://developers.line.biz/console/).
     */
    qrCodeUrl?: string
} & DefaultResponderId &
    DefaultResponderWritable

export type MailgunReadable = IntegrationReadable & {
    type: 'mailgun'
} & {
    /**
     * To configure a Mailgun integration, visit the API Keys tab in the settings page of the Mailgun dashboard and copy your active API key. Call the Create Integration endpoint with your API Key, a domain you have configured in Mailgun, and the incoming address you would like to use. Must have the same domain as the one specified in the domain parameter.
     *
     */
    type?: string
    /**
     * The domain used to relay email. This domain must be configured and verified in your Mailgun account.
     */
    domain: string
    /**
     * Sunshine Conversations will receive all emails sent to this address. It will also be used as the Reply-To address.
     */
    incomingAddress: string
    /**
     * A boolean value indicating whether the unsubscribe link should be omitted from outgoing emails. When enabled, it is expected that the business is providing the user a way to unsubscribe by some other means. By default, the unsubscribe link will be included in all outgoing emails.
     */
    hideUnsubscribeLink?: boolean
    /**
     * Email address to use as the From and Reply-To address if it must be different from incomingAddress. Only use this option if the address that you supply is configured to forward emails to the incomingAddress, otherwise user replies will be lost. You must also make sure that the domain is properly configured as a mail provider so as to not be flagged as spam by the user’s email client. May be unset with null.
     */
    fromAddress?: string | null
} & DefaultResponderReadable

export type MailgunWritable = IntegrationWritable & {
    type: 'mailgun'
} & {
    /**
     * To configure a Mailgun integration, visit the API Keys tab in the settings page of the Mailgun dashboard and copy your active API key. Call the Create Integration endpoint with your API Key, a domain you have configured in Mailgun, and the incoming address you would like to use. Must have the same domain as the one specified in the domain parameter.
     *
     */
    type?: string
    /**
     * The public API key of your Mailgun account.
     */
    apiKey: string | null
    /**
     * The domain used to relay email. This domain must be configured and verified in your Mailgun account.
     */
    domain: string
    /**
     * Sunshine Conversations will receive all emails sent to this address. It will also be used as the Reply-To address.
     */
    incomingAddress: string
    /**
     * A boolean value indicating whether the unsubscribe link should be omitted from outgoing emails. When enabled, it is expected that the business is providing the user a way to unsubscribe by some other means. By default, the unsubscribe link will be included in all outgoing emails.
     */
    hideUnsubscribeLink?: boolean
    /**
     * Email address to use as the From and Reply-To address if it must be different from incomingAddress. Only use this option if the address that you supply is configured to forward emails to the incomingAddress, otherwise user replies will be lost. You must also make sure that the domain is properly configured as a mail provider so as to not be flagged as spam by the user’s email client. May be unset with null.
     */
    fromAddress?: string | null
} & DefaultResponderId &
    DefaultResponderWritable

export type MessagebirdReadable = IntegrationReadable & {
    type: 'messagebird'
} & {
    /**
     * To configure a MessageBird integration, acquire the accessKey, the signingKey and the MessageBird number you would like to use, then call the Create Integration endpoint. The response will include the integration’s `_id` and `webhookSecret`, which must be used to configure the webhook in MessageBird.
     * In the Flow Builder for the MessageBird number you’ve used to integrate, add a new step with the following settings:
     * - Create a new Call HTTP endpoint with SMS flow.
     * - Select your desired SMS number for Incoming SMS.
     * - Click on Forward to URL and set its method to POST.
     * - Then, using the integration _id and webhookSecret returned from the create integration call, enter the following into the URL field:
     * `https://app.smooch.io/api/messagebird/webhooks/{appId}/{integrationId}/{webhookSecret}`
     * - Select application/json for the Set Content-Type header field.
     * - Save and publish your changes.
     *
     */
    type?: string
    /**
     * Sunshine Conversations will receive all messages sent to this phone number.
     */
    originator: string
    /**
     * The secret that is used to configure webhooks in MessageBird.
     */
    readonly webhookSecret?: string
} & DefaultResponderReadable

export type MessagebirdWritable = IntegrationWritable & {
    type: 'messagebird'
} & {
    /**
     * To configure a MessageBird integration, acquire the accessKey, the signingKey and the MessageBird number you would like to use, then call the Create Integration endpoint. The response will include the integration’s `_id` and `webhookSecret`, which must be used to configure the webhook in MessageBird.
     * In the Flow Builder for the MessageBird number you’ve used to integrate, add a new step with the following settings:
     * - Create a new Call HTTP endpoint with SMS flow.
     * - Select your desired SMS number for Incoming SMS.
     * - Click on Forward to URL and set its method to POST.
     * - Then, using the integration _id and webhookSecret returned from the create integration call, enter the following into the URL field:
     * `https://app.smooch.io/api/messagebird/webhooks/{appId}/{integrationId}/{webhookSecret}`
     * - Select application/json for the Set Content-Type header field.
     * - Save and publish your changes.
     *
     */
    type?: string
    /**
     * The public API key of your MessageBird account.
     */
    accessKey: string | null
    /**
     * The signing key of your MessageBird account. Used to validate the webhooks' origin.
     */
    signingKey: string | null
    /**
     * Sunshine Conversations will receive all messages sent to this phone number.
     */
    originator: string
} & DefaultResponderId &
    DefaultResponderWritable

export type MessengerReadable = IntegrationReadable & {
    type: 'messenger'
} & {
    /**
     * Facebook Messenger Setup steps:
     * - Take note of your Facebook app ID and secret (apps can be created at developer.facebook.com);
     * - The Facebook app must have been submitted to Meta for app review with the “pages_manage_metadata” (to retrieve Page Access Tokens for the Pages, apps that the app user administers and set a webhook) and “pages_messaging” (to send messages) permissions.
     * - In order to integrate a Facebook Messenger app you must acquire a Page Access Token from your user. Once you have acquired a page access token from your user, call the Create Integration endpoint with your app secret and ID and the user’s page access token.
     *
     */
    type?: string
    /**
     * A Facebook Page Access Token.
     */
    pageAccessToken: string | null
    /**
     * A Facebook App ID.
     */
    appId: string
    /**
     * A Facebook page ID.
     */
    pageId?: number
    /**
     * A Facebook page name.
     */
    pageName?: string
} & DefaultResponderReadable

export type MessengerWritable = IntegrationWritable & {
    type: 'messenger'
} & {
    /**
     * Facebook Messenger Setup steps:
     * - Take note of your Facebook app ID and secret (apps can be created at developer.facebook.com);
     * - The Facebook app must have been submitted to Meta for app review with the “pages_manage_metadata” (to retrieve Page Access Tokens for the Pages, apps that the app user administers and set a webhook) and “pages_messaging” (to send messages) permissions.
     * - In order to integrate a Facebook Messenger app you must acquire a Page Access Token from your user. Once you have acquired a page access token from your user, call the Create Integration endpoint with your app secret and ID and the user’s page access token.
     *
     */
    type?: string
    /**
     * A Facebook Page Access Token.
     */
    pageAccessToken: string | null
    /**
     * A Facebook App ID.
     */
    appId: string
    /**
     * A Facebook App Secret.
     */
    appSecret: string | null
    /**
     * A Facebook page ID.
     */
    pageId?: number
    /**
     * A Facebook page name.
     */
    pageName?: string
} & DefaultResponderId &
    DefaultResponderWritable

export type TelegramReadable = IntegrationReadable & {
    type: 'telegram'
} & {
    /**
     * To configure a Telegram integration, acquire the required information from the user and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Username of the botId
     */
    readonly username?: string
    /**
     * A human-friendly name used to identify the integration.
     */
    readonly botId?: string
} & DefaultResponderReadable

export type TelegramWritable = IntegrationWritable & {
    type: 'telegram'
} & {
    /**
     * To configure a Telegram integration, acquire the required information from the user and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Telegram Bot Token.
     */
    token: string | null
} & DefaultResponderId &
    DefaultResponderWritable

export type TwilioReadable = IntegrationReadable & {
    type: 'twilio'
} & {
    /**
     * To configure a Twilio integration, acquire the required information from the user and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Twilio Account SID.
     */
    accountSid: string
    /**
     * SID for specific phone number. One of `messagingServiceSid` or `phoneNumberSid` must be provided when creating a Twilio integration.
     */
    phoneNumberSid?: string
    /**
     * SID for specific messaging service. One of `messagingServiceSid` or `phoneNumberSid` must be provided when creating a Twilio integration.
     */
    messagingServiceSid?: string
} & DefaultResponderReadable

export type TwilioWritable = IntegrationWritable & {
    type: 'twilio'
} & {
    /**
     * To configure a Twilio integration, acquire the required information from the user and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Twilio Account SID.
     */
    accountSid: string
    /**
     * Twilio Auth Token.
     */
    authToken: string | null
    /**
     * SID for specific phone number. One of `messagingServiceSid` or `phoneNumberSid` must be provided when creating a Twilio integration.
     */
    phoneNumberSid?: string
    /**
     * SID for specific messaging service. One of `messagingServiceSid` or `phoneNumberSid` must be provided when creating a Twilio integration.
     */
    messagingServiceSid?: string
} & DefaultResponderId &
    DefaultResponderWritable

export type TwitterReadable = IntegrationReadable & {
    type: 'twitter'
} & {
    /**
     * To set up a Twitter integration, please follow the steps outlined in the [Twitter Setup Guide](https://docs.smooch.io/guide/twitter/#setup).
     *
     */
    type?: string
    /**
     * Your Twitter app's tier. Only "enterprise" is supported for new integrations.
     */
    tier: 'enterprise'
    /**
     * The Twitter dev environments label. Only required / used for sandbox and premium tiers.
     */
    readonly envName?: string
} & DefaultResponderReadable

export type TwitterWritable = IntegrationWritable & {
    type: 'twitter'
} & {
    /**
     * To set up a Twitter integration, please follow the steps outlined in the [Twitter Setup Guide](https://docs.smooch.io/guide/twitter/#setup).
     *
     */
    type?: string
    /**
     * Your Twitter app's tier. Only "enterprise" is supported for new integrations.
     */
    tier: 'enterprise'
    /**
     * The consumer key for your Twitter app.
     */
    consumerKey: string
    /**
     * The consumer key secret for your Twitter app.
     */
    consumerSecret: string | null
    /**
     * The access token key obtained from your user via oauth.
     */
    accessTokenKey: string
    /**
     * The access token secret obtained from your user via oauth.
     */
    accessTokenSecret: string | null
} & DefaultResponderId &
    DefaultResponderWritable

export type UnityReadable = IntegrationReadable & {
    type: 'unity'
} & {
    /**
     * To configure a Unity integration, create an integration with type 'unity' by calling the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the Unity integration.
     */
    canUserCreateMoreConversations?: boolean
    /**
     * Allows users to send attachments. By default, the setting is set to true. This setting can only be configured in Zendesk Admin Center.
     *
     */
    readonly attachmentsEnabled?: boolean
} & DefaultResponderReadable

export type UnityWritable = IntegrationWritable & {
    type: 'unity'
} & {
    /**
     * To configure a Unity integration, create an integration with type 'unity' by calling the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the Unity integration.
     */
    canUserCreateMoreConversations?: boolean
} & DefaultResponderId &
    DefaultResponderWritable

export type ViberReadable = IntegrationReadable & {
    type: 'viber'
} & {
    /**
     * To configure a Viber integration, acquire the Viber Public Account token from the user and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Unique URI of the Viber account.
     */
    readonly uri?: string
    /**
     * Unique ID of the Viber account.
     */
    readonly accountId?: string
} & DefaultResponderReadable

export type ViberWritable = IntegrationWritable & {
    type: 'viber'
} & {
    /**
     * To configure a Viber integration, acquire the Viber Public Account token from the user and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * Viber Public Account token.
     */
    token: string | null
} & DefaultResponderId &
    DefaultResponderWritable

export type PrechatCapture = {
    /**
     * Sets the URL of the avatar to use for the automatic reply to the prechat capture messages.
     */
    avatarUrl?: string
    /**
     * If true, enables the Prechat Capture add-on when the Web Messenger is initialized.
     */
    enabled?: boolean
    /**
     * f true and Mailgun is integrated, will automatically link submitted emails.
     */
    enableEmailLinking?: boolean
    /**
     * Array of Fields. Overrides the default Prechat Capture fields to define a custom form.
     */
    fields?: Array<Field>
}

export type WebReadable = IntegrationReadable & {
    type: 'web'
} & {
    /**
     * To configure a Web Messenger integration, acquire the required information and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * This color will be used in the messenger header and the button or tab
     * in idle state. Must be a 3 or 6-character hexadecimal color.
     *
     */
    brandColor?: string
    /**
     * When true, the introduction pane will be pinned at the top of the
     * conversation instead of scrolling with it.
     *
     */
    fixedIntroPane?: boolean
    /**
     * This color will be used for customer messages, quick replies and
     * actions in the footer. Must be a 3 or 6-character hexadecimal color.
     *
     */
    conversationColor?: string
    /**
     * This color will be used for call-to-actions inside your messages. Must
     * be a 3 or 6-character hexadecimal color.
     *
     */
    actionColor?: string
    /**
     * Choose how the messenger will appear on your website. Must be either
     * button or tab.
     *
     */
    displayStyle?: string
    /**
     * With the button style Web Messenger, you have the option of selecting
     * your own button icon. The image must be at least 200 x 200 pixels and
     * must be in either JPG, PNG, or GIF format.
     *
     */
    buttonIconUrl?: string | null
    /**
     * With the button style Web Messenger, you have the option of specifying
     * the button width.
     *
     */
    buttonWidth?: string
    /**
     * With the button style Web Messenger, you have the option of specifying
     * the button height.
     *
     */
    buttonHeight?: string
    /**
     * Array of integration IDs, order will be reflected in the Web
     * Messenger. When set, only integrations from this list will be
     * displayed in the Web Messenger. If unset, all integrations will be
     * displayed.
     *
     */
    integrationOrder?: Array<string> | null
    /**
     * A custom business name for the Web Messenger.
     */
    businessName?: string
    /**
     * A custom business icon url for the Web Messenger. The image must be at
     * least 200 x 200 pixels and must be in either JPG, PNG, or GIF format.
     *
     */
    businessIconUrl?: string
    /**
     * A background image url for the conversation. Image will be tiled to
     * fit the window.
     *
     */
    backgroundImageUrl?: string
    /**
     * A list of origins to whitelist. When set, only the origins from this list will be able to initialize the Web Messenger. If unset, all origins are whitelisted.
     * The elements in the list should follow the serialized-origin format from RFC 6454: scheme "://" host [ ":" port ], where scheme is http or https.
     *
     */
    originWhitelist?: Array<string> | null
    /**
     * Object whose properties can be set to specify the add-on’s options.
     * See the
     * [guide](https://docs.smooch.io/guide/web-messenger/#prechat-capture)
     * to learn more about Prechat Capture.
     *
     */
    prechatCapture?: PrechatCapture
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the web messenger
     * integration.
     *
     */
    canUserCreateMoreConversations?: boolean
    /**
     * Allows users to send attachments. By default, the setting is set to true. This setting can only be configured in Zendesk Admin Center.
     *
     */
    readonly attachmentsEnabled?: boolean
} & DefaultResponderReadable

export type WebWritable = IntegrationWritable & {
    type: 'web'
} & {
    /**
     * To configure a Web Messenger integration, acquire the required information and call the Create Integration endpoint.
     *
     */
    type?: string
    /**
     * This color will be used in the messenger header and the button or tab
     * in idle state. Must be a 3 or 6-character hexadecimal color.
     *
     */
    brandColor?: string
    /**
     * When true, the introduction pane will be pinned at the top of the
     * conversation instead of scrolling with it.
     *
     */
    fixedIntroPane?: boolean
    /**
     * This color will be used for customer messages, quick replies and
     * actions in the footer. Must be a 3 or 6-character hexadecimal color.
     *
     */
    conversationColor?: string
    /**
     * This color will be used for call-to-actions inside your messages. Must
     * be a 3 or 6-character hexadecimal color.
     *
     */
    actionColor?: string
    /**
     * Choose how the messenger will appear on your website. Must be either
     * button or tab.
     *
     */
    displayStyle?: string
    /**
     * With the button style Web Messenger, you have the option of selecting
     * your own button icon. The image must be at least 200 x 200 pixels and
     * must be in either JPG, PNG, or GIF format.
     *
     */
    buttonIconUrl?: string | null
    /**
     * With the button style Web Messenger, you have the option of specifying
     * the button width.
     *
     */
    buttonWidth?: string
    /**
     * With the button style Web Messenger, you have the option of specifying
     * the button height.
     *
     */
    buttonHeight?: string
    /**
     * Array of integration IDs, order will be reflected in the Web
     * Messenger. When set, only integrations from this list will be
     * displayed in the Web Messenger. If unset, all integrations will be
     * displayed.
     *
     */
    integrationOrder?: Array<string> | null
    /**
     * A custom business name for the Web Messenger.
     */
    businessName?: string
    /**
     * A custom business icon url for the Web Messenger. The image must be at
     * least 200 x 200 pixels and must be in either JPG, PNG, or GIF format.
     *
     */
    businessIconUrl?: string
    /**
     * A background image url for the conversation. Image will be tiled to
     * fit the window.
     *
     */
    backgroundImageUrl?: string
    /**
     * A list of origins to whitelist. When set, only the origins from this list will be able to initialize the Web Messenger. If unset, all origins are whitelisted.
     * The elements in the list should follow the serialized-origin format from RFC 6454: scheme "://" host [ ":" port ], where scheme is http or https.
     *
     */
    originWhitelist?: Array<string> | null
    /**
     * Object whose properties can be set to specify the add-on’s options.
     * See the
     * [guide](https://docs.smooch.io/guide/web-messenger/#prechat-capture)
     * to learn more about Prechat Capture.
     *
     */
    prechatCapture?: PrechatCapture
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the web messenger
     * integration.
     *
     */
    canUserCreateMoreConversations?: boolean
} & DefaultResponderId &
    DefaultResponderWritable

export type WhatsappReadable = IntegrationReadable & {
    type: 'whatsapp'
} & {
    /**
     * To configure a WhatsApp integration, use your WhatsApp API Client connection information. Sunshine Conversations can provide WhatsApp API Client hosting for approved brands. See our [WhatsApp guide](https://docs.smooch.io/guide/whatsapp/#whatsapp-api-client) for more details on WhatsApp API Client hosting.
     *
     */
    type?: string
    /**
     * Specify a fallback language to use when sending WhatsApp message template using the short hand syntax. Defaults to en_US. See WhatsApp documentation for more info.
     */
    hsmFallbackLanguage?: string | null
    /**
     * The business ID associated with the WhatsApp account. In combination with accountManagementAccessToken, it’s used for Message Template Reconstruction.
     */
    accountId?: string | null
    /**
     * An access token associated with the accountId used to query the WhatsApp Account Management API. In combination with accountId, it’s used for Message Template Reconstruction.
     */
    accountManagementAccessToken?: string | null
    /**
     * The phone number that is associated with the deployment of this integration, if one exists.
     */
    readonly phoneNumber?: string | null
} & DefaultResponderReadable

export type WhatsappWritable = IntegrationWritable & {
    type: 'whatsapp'
} & {
    /**
     * To configure a WhatsApp integration, use your WhatsApp API Client connection information. Sunshine Conversations can provide WhatsApp API Client hosting for approved brands. See our [WhatsApp guide](https://docs.smooch.io/guide/whatsapp/#whatsapp-api-client) for more details on WhatsApp API Client hosting.
     *
     */
    type?: string
    /**
     * Specify a fallback language to use when sending WhatsApp message template using the short hand syntax. Defaults to en_US. See WhatsApp documentation for more info.
     */
    hsmFallbackLanguage?: string | null
    /**
     * The business ID associated with the WhatsApp account. In combination with accountManagementAccessToken, it’s used for Message Template Reconstruction.
     */
    accountId?: string | null
    /**
     * An access token associated with the accountId used to query the WhatsApp Account Management API. In combination with accountId, it’s used for Message Template Reconstruction.
     */
    accountManagementAccessToken?: string | null
} & DefaultResponderId &
    DefaultResponderWritable

/**
 * The status of the integration.
 */
export type Status = 'inactive' | 'active' | 'error'

export type IntegrationListResponseReadable = {
    /**
     * List of returned integrations.
     */
    integrations?: Array<IntegrationReadable>
    meta?: Meta
    links?: Links
}

export type IntegrationListResponseWritable = {
    /**
     * List of returned integrations.
     */
    integrations?: Array<IntegrationWritable>
    meta?: Meta
    links?: Links
}

/**
 * integrationResponse
 */
export type IntegrationResponseReadable = {
    integration?: IntegrationReadable
}

/**
 * integrationResponse
 */
export type IntegrationResponseWritable = {
    integration?: IntegrationWritable
}

export type IntegrationUpdateBase = {
    /**
     * A human-friendly name used to identify the integration. `displayName` can be unset by changing it to `null`.
     */
    displayName?: string | null
    /**
     * The default responder ID for the integration. This is the ID of the responder that will be used to send messages to the user.
     * For more information, refer to <a href="https://docs.smooch.io/guide/switchboard/#per-channel-default-responder">Per-channel default responder</a> guide.
     *
     */
    defaultResponderId?: string | null
}

export type AndroidUpdateReadable = IntegrationUpdateBase & {
    /**
     * Your sender id from the fcm console.
     * @deprecated
     */
    senderId?: string | null
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the android integration.
     */
    canUserCreateMoreConversations?: boolean
}

export type AndroidUpdateWritable = IntegrationUpdateBase & {
    /**
     * Your project ID from your generated private key file.
     */
    projectId?: string | null
    /**
     * Your client email from your generated private key file.
     */
    clientEmail?: string | null
    /**
     * Your private key from your generated private key file.
     */
    privateKey?: string | null
    /**
     * Your server key from the fcm console.
     * @deprecated
     */
    serverKey?: string | null
    /**
     * Your sender id from the fcm console.
     * @deprecated
     */
    senderId?: string | null
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the android integration.
     */
    canUserCreateMoreConversations?: boolean
}

export type AppleUpdate = IntegrationUpdateBase & {
    /**
     * A secret used to create the state value when sending Apple authentication 2.0 messages
     */
    authenticationMessageSecret?: string
}

export type CustomUpdate = {
    /**
     * A human-friendly name used to identify the integration. `displayName` can be unset by changing it to `null`.
     */
    displayName?: string | null
}

export type InstagramUpdate = IntegrationUpdateBase & {
    /**
     * A Facebook Page Access Token.
     */
    pageAccessToken?: string
}

export type IosUpdateReadable = IntegrationUpdateBase & {
    /**
     * The APN environment to connect to (Production, if true, or Sandbox). Defaults to value inferred from certificate if not specified.
     */
    production?: boolean
    /**
     * Use the unread count of the conversation as the application badge.
     */
    autoUpdateBadge?: boolean
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the iOS integration.
     */
    canUserCreateMoreConversations?: boolean
}

export type IosUpdateWritable = IntegrationUpdateBase & {
    /**
     * The binary of your APN certificate base64 encoded.
     */
    certificate?: string | null
    /**
     * The password for your APN certificate.
     */
    password?: string
    /**
     * The APN environment to connect to (Production, if true, or Sandbox). Defaults to value inferred from certificate if not specified.
     */
    production?: boolean
    /**
     * Use the unread count of the conversation as the application badge.
     */
    autoUpdateBadge?: boolean
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the iOS integration.
     */
    canUserCreateMoreConversations?: boolean
}

export type LineUpdate = IntegrationUpdateBase

export type MailgunUpdate = IntegrationUpdateBase & {
    /**
     * A boolean value indicating whether the unsubscribe link should be omitted from outgoing emails. When enabled, it is expected that the business is providing the user a way to unsubscribe by some other means. By default, the unsubscribe link will be included in all outgoing emails.
     */
    hideUnsubscribeLink?: boolean
    /**
     * Email address to use as the From and Reply-To address if it must be different from incomingAddress. Only use this option if the address that you supply is configured to forward emails to the incomingAddress, otherwise user replies will be lost. You must also make sure that the domain is properly configured as a mail provider so as to not be flagged as spam by the user’s email client. May be unset with null.
     */
    fromAddress?: string | null
}

export type MessageBirdUpdate = IntegrationUpdateBase

export type MessengerUpdate = IntegrationUpdateBase & {
    /**
     * A Facebook Page Access Token.
     */
    pageAccessToken?: string
}

export type TelegramUpdate = IntegrationUpdateBase

export type TwilioUpdate = IntegrationUpdateBase

export type TwitterUpdate = IntegrationUpdateBase

export type UnityUpdate = IntegrationUpdateBase & {
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the Unity integration.
     */
    canUserCreateMoreConversations?: boolean
}

export type ViberUpdate = IntegrationUpdateBase

export type WebUpdate = IntegrationUpdateBase & {
    /**
     * This color will be used in the messenger header and the button or tab in idle state. Must be a 3 or 6-character hexadecimal color.
     */
    brandColor?: string
    /**
     * When true, the introduction pane will be pinned at the top of the conversation instead of scrolling with it.
     */
    fixedIntroPane?: boolean
    /**
     * This color will be used for customer messages, quick replies and actions in the footer. Must be a 3 or 6-character hexadecimal color.
     */
    conversationColor?: string
    /**
     * This color will be used for call-to-actions inside your messages. Must be a 3 or 6-character hexadecimal color.
     */
    actionColor?: string
    /**
     * Choose how the messenger will appear on your website. Must be either button or tab.
     */
    displayStyle?: string
    /**
     * With the button style Web Messenger, you have the option of selecting your own button icon. The image must be at least 200 x 200 pixels and must be in either JPG, PNG, or GIF format.
     */
    buttonIconUrl?: string | null
    /**
     * With the button style Web Messenger, you have the option of specifying the button width.
     */
    buttonWidth?: string
    /**
     * With the button style Web Messenger, you have the option of specifying the button height.
     */
    buttonHeight?: string
    /**
     * Array of integration IDs, order will be reflected in the Web Messenger. When set, only integrations from this list will be displayed in the Web Messenger. If unset, all integrations will be displayed.
     */
    integrationOrder?: Array<string> | null
    /**
     * A custom business name for the Web Messenger.
     */
    businessName?: string
    /**
     * A custom business icon url for the Web Messenger. The image must be at least 200 x 200 pixels and must be in either JPG, PNG, or GIF format.
     */
    businessIconUrl?: string
    /**
     * A background image url for the conversation. Image will be tiled to fit the window.
     */
    backgroundImageUrl?: string
    /**
     * A list of origins to whitelist. When set, only the origins from this list will be able to initialize the Web Messenger. If unset, all origins are whitelisted.
     * The elements in the list should follow the serialized-origin format from RFC 6454: scheme "://" host [ ":" port ], where scheme is http or https.
     *
     */
    originWhitelist?: Array<string> | null
    /**
     * Object whose properties can be set to specify the add-on’s options. See the [guide](https://docs.smooch.io/guide/web-messenger/#prechat-capture) to learn more about Prechat Capture.
     */
    prechatCapture?: PrechatCapture
    /**
     * Allows users to view their list of conversations. By default, the list
     * of conversations will be visible. *This setting only applies to apps
     * where `settings.multiConvoEnabled` is set to `true`*.
     *
     */
    canUserSeeConversationList?: boolean
    /**
     * Allows users to create more than one conversation on the web messenger integration.
     */
    canUserCreateMoreConversations?: boolean
}

export type WhatsAppUpdate = IntegrationUpdateBase & {
    /**
     * Specify a fallback language to use when sending WhatsApp message template using the short hand syntax. Defaults to en_US. See WhatsApp documentation for more info.
     */
    hsmFallbackLanguage?: string | null
    /**
     * The business ID associated with the WhatsApp account. In combination with accountManagementAccessToken, it’s used for Message Template Reconstruction.
     */
    accountId?: string | null
    /**
     * An access token associated with the accountId used to query the WhatsApp Account Management API. In combination with accountId, it’s used for Message Template Reconstruction.
     */
    accountManagementAccessToken?: string | null
}

export type IntegrationUpdateReadable =
    | AndroidUpdateReadable
    | AppleUpdate
    | CustomUpdate
    | InstagramUpdate
    | IosUpdateReadable
    | LineUpdate
    | MailgunUpdate
    | MessageBirdUpdate
    | MessengerUpdate
    | TelegramUpdate
    | TwilioUpdate
    | TwitterUpdate
    | UnityUpdate
    | ViberUpdate
    | WebUpdate
    | WhatsAppUpdate

export type IntegrationUpdateWritable =
    | AndroidUpdateWritable
    | AppleUpdate
    | CustomUpdate
    | InstagramUpdate
    | IosUpdateWritable
    | LineUpdate
    | MailgunUpdate
    | MessageBirdUpdate
    | MessengerUpdate
    | TelegramUpdate
    | TwilioUpdate
    | TwitterUpdate
    | UnityUpdate
    | ViberUpdate
    | WebUpdate
    | WhatsAppUpdate

/**
 * The integration key.
 */
export type ApiKey = {
    /**
     * The unique ID of the API key, used when signing JWTs or accessing the API using Basic Authentication.
     */
    id?: string
    /**
     * The name of the API key.
     */
    displayName?: DisplayName
    /**
     * The secret of the API key, used when signing JWTs or accessing the API using Basic Authentication
     */
    secret?: string
}

export type IntegrationApiKeyResponse = {
    key?: ApiKey
}

export type WebhookListResponseReadable = {
    /**
     * List of webhooks associated with the integration.
     */
    webhooks?: Array<WebhookReadable>
}

export type WebhookListResponseWritable = {
    /**
     * List of webhooks associated with the integration.
     */
    webhooks?: Array<WebhookWritable>
}

export type WebhookBody = {
    target?: Target
    triggers?: Triggers
    includeFullUser?: IncludeFullUser
    includeFullSource?: IncludeFullSource
}

export type WebhookCreateBody = WebhookBody

/**
 * WebhookResponse
 */
export type WebhookResponseReadable = {
    /**
     * The webhook.
     */
    webhook?: WebhookReadable
}

/**
 * WebhookResponse
 */
export type WebhookResponseWritable = {
    /**
     * The webhook.
     */
    webhook?: WebhookWritable
}

/**
 * Whether the switchboard is enabled. Allows creating the switchboard in a disabled state so that messages don't get lost or misrouted during switchboard configuration. When a switchboard is disabled, integrations linked to the switchboard will receive all events.
 */
export type Enabled = boolean

/**
 * The id of the switchboard integration that will be given control when a new conversation begins. It will also be used for conversations that existed before the switchboard was enabled.
 */
export type DefaultSwitchboardIntegrationId = string

export type Switchboard = {
    /**
     * The unique ID of the switchboard.
     */
    id: string
    enabled: Enabled
    defaultSwitchboardIntegrationId?: DefaultSwitchboardIntegrationId
}

export type SwitchboardListResponse = {
    /**
     * List of returned switchboards.
     */
    switchboards?: Array<Switchboard>
}

/**
 * SwitchboardResponse
 */
export type SwitchboardResponse = {
    /**
     * The switchboard.
     */
    switchboard?: Switchboard
}

export type SwitchboardUpdateBody = {
    enabled?: Enabled
    defaultSwitchboardIntegrationId?: DefaultSwitchboardIntegrationId
}

/**
 * Setting to determine if webhooks should be sent when the switchboard integration is not in control of a conversation (standby status)
 */
export type DeliverStandbyEvents = boolean

/**
 * The switchboard integration id to which control of a conversation is passed / offered by default.
 */
export type NextSwitchboardIntegrationId = string | null

/**
 * Number of messages to include in the message history context.
 */
export type MessageHistoryCount = number | null

export type SwitchboardIntegration = {
    /**
     * The unique ID of the switchboard integration.
     */
    id: string
    name: Name
    integrationId: SwitchboardIntegrationId
    integrationType: SwitchboardIntegrationType
    deliverStandbyEvents: DeliverStandbyEvents
    nextSwitchboardIntegrationId?: NextSwitchboardIntegrationId
    messageHistoryCount?: MessageHistoryCount
}

export type SwitchboardIntegrationListResponse = {
    /**
     * List of returned switchboard integrations.
     */
    switchboardIntegrations?: Array<SwitchboardIntegration>
}

export type SwitchboardIntegrationCreateBody = {
    name: Name
    /**
     * The id of the integration to link to the switchboard integration. Must be used when linking a custom integration. One of `integrationId` or `integrationType` must be provided.
     */
    integrationId?: SwitchboardIntegrationId
    /**
     * The type of the integration to link to the switchboard integration. Must be used when linking an OAuth integration. One of `integrationId` or `integrationType` must be provided.
     */
    integrationType?: SwitchboardIntegrationType
    deliverStandbyEvents?: DeliverStandbyEvents
    nextSwitchboardIntegrationId?: NextSwitchboardIntegrationId
    messageHistoryCount?: MessageHistoryCount
}

/**
 * SwitchboardIntegrationResponse
 */
export type SwitchboardIntegrationResponse = {
    /**
     * The switchboard integration.
     */
    switchboardIntegration?: SwitchboardIntegration
}

export type SwitchboardIntegrationUpdateBody = {
    name?: Name
    /**
     * The id of the integration to link to the switchboard integration. Must be used when linking a custom integration. Can't provide both `integrationId` and `integrationType`.
     */
    integrationId?: SwitchboardIntegrationId
    /**
     * The type of the integration to link to the switchboard integration. Must be used when linking an OAuth integration. Can't provide both `integrationId` and `integrationType`.
     */
    integrationType?: SwitchboardIntegrationType
    deliverStandbyEvents?: DeliverStandbyEvents
    nextSwitchboardIntegrationId?: NextSwitchboardIntegrationId
    messageHistoryCount?: MessageHistoryCount
}

/**
 * The date at which the user signed up. Must be ISO 8601 time format `YYYY-MM-DDThh:mm:ss.sssZ`.
 */
export type SignedUpAt = string

/**
 * Flag indicating whether a user should be retained after they have passed their inactive expiry. See [creating deletion schedules for bot-only conversations](https://support.zendesk.com/hc/en-us/articles/8499219792154) for more information.
 */
export type ToBeRetained = boolean

/**
 * Object hosting user profile information.
 */
export type Profile = {
    /**
     * The user's given name (first name).
     */
    givenName?: string | null
    /**
     * The user's surname (last name).
     */
    surname?: string | null
    /**
     * The user's email address.
     */
    email?: string | null
    /**
     * The user's avatar.
     */
    avatarUrl?: string | null
    /**
     * End-user's locale information in BCP 47 format.
     */
    locale?: string | null
}

/**
 * UserCreateBody
 */
export type UserCreateBody = {
    /**
     * A unique identifier for the user. The `externalId` can be used to link a user to the same conversation [across multiple devices](https://docs.smooch.io/guide/authenticating-users/).
     *
     */
    externalId: string
    signedUpAt?: SignedUpAt
    toBeRetained?: ToBeRetained
    profile?: Profile
    metadata?: Metadata
}

export type UserTruncatedReadable = {
    /**
     * The unique ID of the user.
     */
    id?: string
    /**
     * Whether or not the user has authenticated, either via JWT or via the Help Center
     */
    readonly authenticated?: boolean
    /**
     * An optional ID that can also be used to retrieve the user.
     *
     */
    externalId?: string | null
    /**
     * The ID that links a messaging user to its core Zendesk user counterpart. This ID can be used to fetch the core user record via the Zendesk Support API.
     *
     */
    zendeskId?: string | null
}

export type UserTruncatedWritable = {
    /**
     * The unique ID of the user.
     */
    id?: string
    /**
     * An optional ID that can also be used to retrieve the user.
     *
     */
    externalId?: string | null
    /**
     * The ID that links a messaging user to its core Zendesk user counterpart. This ID can be used to fetch the core user record via the Zendesk Support API.
     *
     */
    zendeskId?: string | null
}

/**
 * A connected user identity, such as an email.
 */
export type Identity = {
    /**
     * The type of identity.
     */
    type?: string
    /**
     * The identity value.
     */
    value?: string
    /**
     * The type of verification performed on the identity.
     */
    verification?: string
}

export type UserReadable = UserTruncatedReadable & {
    signedUpAt?: SignedUpAt
    toBeRetained?: ToBeRetained
    profile?: Profile
    metadata?: Metadata
    /**
     * The user's connected identities.
     */
    readonly identities?: Array<Identity>
}

export type UserWritable = UserTruncatedWritable & {
    signedUpAt?: SignedUpAt
    toBeRetained?: ToBeRetained
    profile?: Profile
    metadata?: Metadata
}

/**
 * UserResponse
 */
export type UserResponseReadable = {
    /**
     * The user.
     */
    user?: UserReadable
}

/**
 * UserResponse
 */
export type UserResponseWritable = {
    /**
     * The user.
     */
    user?: UserWritable
}

/**
 * UserUpdateBody
 */
export type UserUpdateBody = {
    signedUpAt?: SignedUpAt
    toBeRetained?: ToBeRetained
    profile?: Profile
    metadata?: Metadata
}

export type ClientListResponse = {
    /**
     * List of returned clients.
     */
    clients?: Array<Client>
    meta?: Meta
    links?: Links
}

export type MatchCriteriaMailgun = MatchCriteriaBase & {
    /**
     * The channel type.
     */
    type?: string
    /**
     * The user’s email address.
     */
    address: string
    /**
     * May be specified to set the subject for the outgoing email.
     */
    subject?: string
}

export type MatchCriteriaMessagebird = MatchCriteriaBase & {
    /**
     * The channel type.
     */
    type?: string
    /**
     * The user’s phone number. It must contain the + prefix and the country code.
     * Examples of valid phone numbers: +1 212-555-2368, +12125552368, +1 212 555 2368.
     * Examples of invalid phone numbers: 212 555 2368, 1 212 555 2368.
     *
     */
    phoneNumber: string
}

export type MatchCriteriaTwilio = MatchCriteriaBase & {
    /**
     * The channel type.
     */
    type?: string
    /**
     * The user’s phone number. It must contain the + prefix and the country code.
     * Examples of valid phone numbers: +1 212-555-2368, +12125552368, +1 212 555 2368.
     * Examples of invalid phone numbers: 212 555 2368, 1 212 555 2368.
     *
     */
    phoneNumber: string
}

export type MatchCriteriaWhatsapp = MatchCriteriaBase & {
    /**
     * The channel type.
     */
    type?: string
    /**
     * The user’s phone number. It must contain the + prefix and the country code.
     * Examples of valid phone numbers: +1 212-555-2368, +12125552368, +1 212 555 2368.
     * Examples of invalid phone numbers: 212 555 2368, 1 212 555 2368.
     *
     */
    phoneNumber: string
}

/**
 * The set of criteria used to determine the user's identity on a third-party channel.
 */
export type MatchCriteriaBase = {
    /**
     * The channel type.
     */
    type: string
    /**
     * The ID of the integration to link. Must match the provided type.
     */
    integrationId: string
    /**
     * Flag indicating whether the client will become the primary for the target conversation once linking is complete.
     */
    primary?: boolean
}

/**
 * The set of criteria used to determine the user's identity on a third-party channel.
 */
export type MatchCriteria =
    | ({
          type: 'mailgun'
      } & MatchCriteriaMailgun)
    | ({
          type: 'messagebird'
      } & MatchCriteriaMessagebird)
    | ({
          type: 'twilio'
      } & MatchCriteriaTwilio)
    | ({
          type: 'whatsapp'
      } & MatchCriteriaWhatsapp)

export type ClientCreateReadable = {
    matchCriteria: MatchCriteria
    /**
     * Confirmation
     * The confirmation options of the link request.
     */
    confirmation: {
        /**
         * The type of confirmation.
         */
        type: 'immediate' | 'userActivity' | 'prompt'
        /**
         * The message used to reach out to the user, if desired. Messages sent via this method can only be of type text and image. If actions are included they can only be of type link. The confirmation message will not be added to the user’s conversation.
         */
        message?: MessagePostReadable
    }
    /**
     * Target
     * The target conversation to attach the client to.
     */
    target: {
        /**
         * The conversation ID of the target conversation.
         */
        conversationId: string
    }
}

export type ClientCreateWritable = {
    matchCriteria: MatchCriteria
    /**
     * Confirmation
     * The confirmation options of the link request.
     */
    confirmation: {
        /**
         * The type of confirmation.
         */
        type: 'immediate' | 'userActivity' | 'prompt'
        /**
         * The message used to reach out to the user, if desired. Messages sent via this method can only be of type text and image. If actions are included they can only be of type link. The confirmation message will not be added to the user’s conversation.
         */
        message?: MessagePostWritable
    }
    /**
     * Target
     * The target conversation to attach the client to.
     */
    target: {
        /**
         * The conversation ID of the target conversation.
         */
        conversationId: string
    }
}

export type DeviceListResponse = {
    /**
     * List of returned devices.
     */
    devices?: Array<Device>
}

/**
 * deviceResponse
 */
export type DeviceResponse = {
    /**
     * The device.
     */
    device?: Device
}

export type SyncUserBody = {
    /**
     * Only used for synchronizing messaging users when their Support user counterparts have been merged. The user.id of the surviving Support user is specified here.
     *
     */
    survivingZendeskId?: string
}

/**
 * The app that triggered the events.
 */
export type AppSubSchema = {
    /**
     * The unique ID of the app.
     */
    id?: string
}

/**
 * The webhook that generated the payload.
 */
export type WebhookSubSchema = {
    /**
     * The unique ID of the webhook.
     */
    id?: string
    /**
     * Schema version of the payload delivered to this webhook (v2).
     */
    version?: string
}

export type EventSubSchema = {
    /**
     * The unique ID of the event. May be used to ensure that an event is not processed twice in the case of a webhook that is re-tried due to an error or timeout.
     */
    id?: string
    /**
     * The type of the event. Will match one of the subscribed triggers for your [webhook](#operation/createWebhook).
     */
    type?: string
    /**
     * A timestamp signifying when the event was generated. Formatted as `YYYY-MM-DDThh:mm:ss.SSSZ`.
     */
    createdAt?: string
}

export type SourceWebhook = {
    /**
     * An identifier for the channel from which a message originated. May include one of api, sdk, messenger, or any number of other channels.
     */
    type?: string
    /**
     * Identifier indicating which integration the message was sent from. For user messages only.
     */
    integrationId?: string
    /**
     * Message identifier assigned by the originating channel.
     */
    originalMessageId?: string | null
    /**
     * A datetime string with the format YYYY-MM-DDThh:mm:ss.SSSZ representing when the third-party channel received the message.
     */
    originalMessageTimestamp?: string | null
    /**
     * The client from which the user authored the message or activity, if applicable. This field will only be present if the `includeFullSource` option is enabled for the webhook.
     */
    client?: Client | null
    /**
     * The device from which the user authored the message or activity, if applicable. This field will only be present if the `includeFullSource` option is enabled for the webhook
     */
    device?: Device | null
}

/**
 * client:add
 */
export type ClientAddEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation associated with the creation of the client. This field is only present
         * when the reason is `channelLinking` and when attaching the client to a specific conversation.
         *
         */
        conversation?: ConversationTruncated | null
        /**
         * The user associated with the client.
         */
        user?: UserTruncatedReadable
        /**
         * The client that was just created.
         */
        client?: Client
        /**
         * The reason for which the client was added.
         * * `channelLinking` - The client was created as a result of initiating a channel link.
         * * `sdkLogin` - The client was created as a result of logging into an SDK device.
         * * `authCode` - The client was created as a result of initializing an SDK client with an `authCode`.
         *
         */
        reason?: 'channelLinking' | 'sdkLogin' | 'authCode'
        /**
         * The source where this event originated from. This could be the API or an SDK device.
         */
        source?: SourceWebhook
    }
}

/**
 * client:add
 */
export type ClientAddEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation associated with the creation of the client. This field is only present
         * when the reason is `channelLinking` and when attaching the client to a specific conversation.
         *
         */
        conversation?: ConversationTruncated | null
        /**
         * The user associated with the client.
         */
        user?: UserTruncatedWritable
        /**
         * The client that was just created.
         */
        client?: Client
        /**
         * The reason for which the client was added.
         * * `channelLinking` - The client was created as a result of initiating a channel link.
         * * `sdkLogin` - The client was created as a result of logging into an SDK device.
         * * `authCode` - The client was created as a result of initializing an SDK client with an `authCode`.
         *
         */
        reason?: 'channelLinking' | 'sdkLogin' | 'authCode'
        /**
         * The source where this event originated from. This could be the API or an SDK device.
         */
        source?: SourceWebhook
    }
}

/**
 * client:remove
 */
export type ClientRemoveEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation associated with the removal of the client. This field is only present
         * when the reason is `theft`, `linkCancelled` or `linkFailed`.
         * Note that for the `theft` reason, the conversation will not be present if it has been deleted.
         *
         */
        conversation?: ConversationTruncated | null
        /**
         * The user associated with the client.
         */
        user?: UserTruncatedReadable
        /**
         * The removed client.
         */
        client?: Client
        /**
         * The reason for which the client was removed.
         * * `api` - The client was removed using the API.
         * * `linkCancelled` - The user cancelled a channel link.
         * * `linkFailed` - The client was removed after a channel link attempt failed.
         * * `sdk` - The client was removed using the SDK.
         * * `theft` - The client was transferred to another user due to a channel link.
         *
         */
        reason?: 'api' | 'linkCancelled' | 'linkFailed' | 'sdk' | 'theft'
        /**
         * Object containing details of what went wrong. This field will only be present when the reason is `linkCancelled` or `linkFailed`.
         */
        error?: {
            [key: string]: unknown
        } | null
        /**
         * The source where this event originated from. This could be the API or an SDK device.
         */
        source?: SourceWebhook
    }
}

/**
 * client:remove
 */
export type ClientRemoveEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation associated with the removal of the client. This field is only present
         * when the reason is `theft`, `linkCancelled` or `linkFailed`.
         * Note that for the `theft` reason, the conversation will not be present if it has been deleted.
         *
         */
        conversation?: ConversationTruncated | null
        /**
         * The user associated with the client.
         */
        user?: UserTruncatedWritable
        /**
         * The removed client.
         */
        client?: Client
        /**
         * The reason for which the client was removed.
         * * `api` - The client was removed using the API.
         * * `linkCancelled` - The user cancelled a channel link.
         * * `linkFailed` - The client was removed after a channel link attempt failed.
         * * `sdk` - The client was removed using the SDK.
         * * `theft` - The client was transferred to another user due to a channel link.
         *
         */
        reason?: 'api' | 'linkCancelled' | 'linkFailed' | 'sdk' | 'theft'
        /**
         * Object containing details of what went wrong. This field will only be present when the reason is `linkCancelled` or `linkFailed`.
         */
        error?: {
            [key: string]: unknown
        } | null
        /**
         * The source where this event originated from. This could be the API or an SDK device.
         */
        source?: SourceWebhook
    }
}

/**
 * client:update
 */
export type ClientUpdateEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation which triggered a change in the client.
         */
        conversation?: ConversationTruncated
        /**
         * The user associated with the client.
         */
        user?: UserTruncatedReadable
        /**
         * The updated client.
         */
        client?: Client
        /**
         * The reason for which the client was updated.
         * * `confirmed` - The client is now active and ready to use.
         * * `blocked` - The user has unsubscribed from the conversation.
         * * `unblocked` - A previously unsubscribed user resubscribed to the conversation.
         * * `matched` - The channel found a user that matches the information provided.
         *
         */
        reason?: 'confirmed' | 'blocked' | 'unblocked' | 'matched'
    }
}

/**
 * client:update
 */
export type ClientUpdateEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation which triggered a change in the client.
         */
        conversation?: ConversationTruncated
        /**
         * The user associated with the client.
         */
        user?: UserTruncatedWritable
        /**
         * The updated client.
         */
        client?: Client
        /**
         * The reason for which the client was updated.
         * * `confirmed` - The client is now active and ready to use.
         * * `blocked` - The user has unsubscribed from the conversation.
         * * `unblocked` - A previously unsubscribed user resubscribed to the conversation.
         * * `matched` - The channel found a user that matches the information provided.
         *
         */
        reason?: 'confirmed' | 'blocked' | 'unblocked' | 'matched'
    }
}

/**
 * The campaign the user interacted with (if applicable).
 */
export type Campaign = {
    /**
     * The unique ID of the campaign.
     */
    id?: string
} | null

export type SourceWithCampaignWebhook = SourceWebhook & {
    campaign?: Campaign
}

/**
 * Data representing a referral object when a user is referred to a conversation. See the <a href="https://docs.smooch.io/guide/conversation-referrals/">conversation referrals</a> guide for more details.
 *
 */
export type Referral = {
    /**
     * The referral’s identifier.
     */
    code?: string
    /**
     * Nested object containing additional information.
     */
    details?: {
        /**
         * The source of the referral - MESSENGER_CODE, ADS etc…
         */
        source?: string
        /**
         * The type of referral, typically OPEN-THREAD.
         */
        type?: string
        /**
         * If the referral came from an ad, this field will be present with the ad’s Id.
         */
        adId?: string | null
    } | null
}

/**
 * conversation:create
 */
export type ConversationCreateEvent = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation that was created.
         */
        conversation?: ConversationTruncated
        /**
         * The reason why the conversation was created, if applicable.
         * * `linkRequest` - The conversation was created in order to generate a link request to transfer the user to a different channel.
         * * `message` - The conversation was created because a message was sent.
         * * `none` - The conversation was not created for a specific purpose. Used primarily when a conversation is created via the Create Conversation API.
         * * `notification` - The conversation was created by a call to the Notification API.
         * * `prechatCapture` - The conversation was created because the user completed a prechat capture form in the Web Messenger.
         * * `startConversation` - The conversation was created because of a call to the startConversation API on one of the SDK integrations, or a start conversation event was triggered from a messaging channel.
         * * `proactiveMessaging` - The conversation was created because the user interacted with a campaign.
         *
         */
        creationReason?:
            | 'linkRequest'
            | 'message'
            | 'none'
            | 'notification'
            | 'prechatCapture'
            | 'startConversation'
            | 'proactiveMessaging'
        /**
         * The source of the creation.
         */
        source?: SourceWithCampaignWebhook
        /**
         * The user associated with the conversation. Only present if the created conversation was of type personal. For sdkGroup conversations, the list of participants can be fetched using the List Participants API, if required.
         */
        user?: UserReadable | null
        /**
         * Referral information, if applicable.
         */
        referral?: Referral | null
    }
}

/**
 * conversation:join
 */
export type ConversationJoinEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the user was added.
         */
        conversation?: ConversationTruncated
        /**
         * The user that joined the conversation.
         */
        user?: UserTruncatedReadable
    }
}

/**
 * conversation:join
 */
export type ConversationJoinEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the user was added.
         */
        conversation?: ConversationTruncated
        /**
         * The user that joined the conversation.
         */
        user?: UserTruncatedWritable
    }
}

/**
 * conversation:leave
 */
export type ConversationLeaveEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the user was removed.
         */
        conversation?: ConversationTruncated
        /**
         * The user that left the conversation.
         */
        user?: UserTruncatedReadable
    }
}

/**
 * conversation:leave
 */
export type ConversationLeaveEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the user was removed.
         */
        conversation?: ConversationTruncated
        /**
         * The user that left the conversation.
         */
        user?: UserTruncatedWritable
    }
}

/**
 * conversation:remove
 */
export type ConversationRemoveEvent = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation that was deleted.
         */
        conversation?: ConversationTruncated
    }
}

/**
 * The payload of the event. The contents of this object depend on the type of event.
 */
export type ConversationMessageDeliveryPayloadReadable = {
    /**
     * The user associated with the conversation.
     */
    user?: UserReadable
    /**
     * The conversation in which the message was sent.
     */
    conversation?: ConversationTruncated
    /**
     * The message that was sent.
     */
    message?: {
        /**
         * A string representing the ID of the message.
         */
        id?: string
    }
    /**
     * A nested object representing the destination of the message.
     */
    destination?: {
        /**
         * An identifier for the channel to which a message was sent to. May include one of "web", "ios", "android", "messenger", "viber", "telegram", "wechat", "line", "twilio", "api", "notification", or any other channel.
         */
        type?: string
        /**
         * Identifier indicating which integration the message was sent to.
         */
        integrationId?: string
    }
    /**
     * An array of objects representing the third-party messages associated with the event. The order of the external messages is not guaranteed to be the same across the different triggers. Note that some channels don’t expose message IDs, in which case this field will be unset.
     */
    externalMessages?: Array<{
        /**
         * A string representing the ID of the external message.
         */
        id?: string
    }> | null
    /**
     * A boolean indicating whether the webhook is the final one for the `message.id` and `destination.type` pair.
     */
    isFinalEvent?: boolean
}

/**
 * The payload of the event. The contents of this object depend on the type of event.
 */
export type ConversationMessageDeliveryPayloadWritable = {
    /**
     * The user associated with the conversation.
     */
    user?: UserWritable
    /**
     * The conversation in which the message was sent.
     */
    conversation?: ConversationTruncated
    /**
     * The message that was sent.
     */
    message?: {
        /**
         * A string representing the ID of the message.
         */
        id?: string
    }
    /**
     * A nested object representing the destination of the message.
     */
    destination?: {
        /**
         * An identifier for the channel to which a message was sent to. May include one of "web", "ios", "android", "messenger", "viber", "telegram", "wechat", "line", "twilio", "api", "notification", or any other channel.
         */
        type?: string
        /**
         * Identifier indicating which integration the message was sent to.
         */
        integrationId?: string
    }
    /**
     * An array of objects representing the third-party messages associated with the event. The order of the external messages is not guaranteed to be the same across the different triggers. Note that some channels don’t expose message IDs, in which case this field will be unset.
     */
    externalMessages?: Array<{
        /**
         * A string representing the ID of the external message.
         */
        id?: string
    }> | null
    /**
     * A boolean indicating whether the webhook is the final one for the `message.id` and `destination.type` pair.
     */
    isFinalEvent?: boolean
}

/**
 * conversation:message:delivery:channel
 */
export type ConversationMessageDeliveryChannelEventReadable = EventSubSchema & {
    payload?: ConversationMessageDeliveryPayloadReadable
}

/**
 * conversation:message:delivery:channel
 */
export type ConversationMessageDeliveryChannelEventWritable = EventSubSchema & {
    payload?: ConversationMessageDeliveryPayloadWritable
}

/**
 * conversation:message:delivery:failure
 */
export type ConversationMessageDeliveryFailureEventReadable = EventSubSchema & {
    payload?: ConversationMessageDeliveryPayloadReadable & {
        /**
         * A nested object representing the error associated with the delivery failure.
         */
        error?: {
            /**
             * A string representing the error code associated with the error.
             */
            code?: string
            /**
             * The description associated with the error.
             */
            message?: string
        }
    }
}

/**
 * conversation:message:delivery:failure
 */
export type ConversationMessageDeliveryFailureEventWritable = EventSubSchema & {
    payload?: ConversationMessageDeliveryPayloadWritable & {
        /**
         * A nested object representing the error associated with the delivery failure.
         */
        error?: {
            /**
             * A string representing the error code associated with the error.
             */
            code?: string
            /**
             * The description associated with the error.
             */
            message?: string
        }
    }
}

/**
 * conversation:message:delivery:user
 */
export type ConversationMessageDeliveryUserEventReadable = EventSubSchema & {
    payload?: ConversationMessageDeliveryPayloadReadable
}

/**
 * conversation:message:delivery:user
 */
export type ConversationMessageDeliveryUserEventWritable = EventSubSchema & {
    payload?: ConversationMessageDeliveryPayloadWritable
}

/**
 * The author of the activity.
 */
export type AuthorWebhookReadable = {
    /**
     * The `type` of the author.
     */
    type: 'business' | 'user'
    /**
     * The id of the user. Only supported when author `type` is `user`.
     */
    userId?: string
    /**
     * The user that authored the message or activity. `profile` is included in the payload if the `includeFullUser` option is enabled.
     */
    user?: UserReadable
}

/**
 * The author of the activity.
 */
export type AuthorWebhookWritable = {
    /**
     * The `type` of the author.
     */
    type: 'business' | 'user'
    /**
     * The id of the user. Only supported when author `type` is `user`.
     */
    userId?: string
    /**
     * The user that authored the message or activity. `profile` is included in the payload if the `includeFullUser` option is enabled.
     */
    user?: UserWritable
}

export type MessageWebhookReadable = {
    /**
     * The unique ID of the message.
     */
    id?: string
    /**
     * A datetime string with the format `YYYY-MM-DDThh:mm:ss.SSSZ` representing when Sunshine Conversations received the message.
     */
    received?: string
    author?: AuthorWebhookReadable
    /**
     * The content of the message.
     */
    content?: ContentReadable & {
        type?: 'messageWebhook'
    }
    source?: Source & {
        campaign?: Campaign
    }
    /**
     * The quoted message is currently only available for WhatsApp and Web Messenger `formResponse` messages.
     */
    quotedMessage?:
        | (QuotedMessageReadable & {
              type?: 'messageWebhook'
          })
        | null
    metadata?: Metadata | null
    /**
     * true if the message serves as a placeholder for one that has been deleted.
     */
    deleted?: boolean | null
}

export type MessageWebhookWritable = {
    /**
     * The unique ID of the message.
     */
    id?: string
    /**
     * A datetime string with the format `YYYY-MM-DDThh:mm:ss.SSSZ` representing when Sunshine Conversations received the message.
     */
    received?: string
    author?: AuthorWebhookWritable
    /**
     * The content of the message.
     */
    content?: ContentWritable & {
        type?: 'messageWebhook'
    }
    source?: Source & {
        campaign?: Campaign
    }
    /**
     * The quoted message is currently only available for WhatsApp and Web Messenger `formResponse` messages.
     */
    quotedMessage?:
        | (QuotedMessageWritable & {
              type?: 'messageWebhook'
          })
        | null
    metadata?: Metadata | null
    /**
     * true if the message serves as a placeholder for one that has been deleted.
     */
    deleted?: boolean | null
}

/**
 * conversation:message
 */
export type ConversationMessageEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the message was sent.
         */
        conversation?: ConversationTruncated
        /**
         * The message that was sent.
         */
        message?: MessageWebhookReadable
        /**
         * Messages sent with the Notification API since the last user message.
         */
        recentNotifications?: Array<MessageWebhookReadable>
    }
}

/**
 * conversation:message
 */
export type ConversationMessageEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the message was sent.
         */
        conversation?: ConversationTruncated
        /**
         * The message that was sent.
         */
        message?: MessageWebhookWritable
        /**
         * Messages sent with the Notification API since the last user message.
         */
        recentNotifications?: Array<MessageWebhookWritable>
    }
}

export type PostbackWebhook = {
    /**
     * The payload associated with the postback.
     */
    payload?: string
    metadata?: Metadata
}

/**
 * conversation:postback
 */
export type ConversationPostbackEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The postback associated with the event.
         */
        postback?: PostbackWebhook
        /**
         * The conversation linked to the postback.
         */
        conversation?: ConversationTruncated
        /**
         * The user that triggered the postback.
         */
        user?: UserReadable
        /**
         * The source of the postback.
         */
        source?: SourceWithCampaignWebhook
    }
}

/**
 * conversation:postback
 */
export type ConversationPostbackEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The postback associated with the event.
         */
        postback?: PostbackWebhook
        /**
         * The conversation linked to the postback.
         */
        conversation?: ConversationTruncated
        /**
         * The user that triggered the postback.
         */
        user?: UserWritable
        /**
         * The source of the postback.
         */
        source?: SourceWithCampaignWebhook
    }
}

export type ActivityReadable = ActivityTypes & {
    /**
     * The source of the activity.
     */
    source?: SourceWebhook
    author?: AuthorWebhookReadable
}

export type ActivityWritable = ActivityTypes & {
    /**
     * The source of the activity.
     */
    source?: SourceWebhook
    author?: AuthorWebhookWritable
}

/**
 * conversation:read
 */
export type ConversationReadEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the message was read.
         */
        conversation?: ConversationTruncated
        /**
         * The activity that was sent.
         */
        activity?: ActivityReadable & {
            /**
             * The type of activity.
             */
            type?: string
        }
    }
}

/**
 * conversation:read
 */
export type ConversationReadEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the message was read.
         */
        conversation?: ConversationTruncated
        /**
         * The activity that was sent.
         */
        activity?: ActivityWritable & {
            /**
             * The type of activity.
             */
            type?: string
        }
    }
}

/**
 * conversation:referral
 */
export type ConversationReferralEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation a user lands in after being referred. See the <a href="https://docs.smooch.io/guide/conversation-referrals/">conversation referrals</a> guide for more details.
         */
        conversation?: ConversationTruncated
        /**
         * The user associated with the conversation.
         */
        user?: UserReadable
        /**
         * The source of the referral.
         */
        source?: SourceWithCampaignWebhook
        referral?: Referral
    }
}

/**
 * conversation:referral
 */
export type ConversationReferralEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation a user lands in after being referred. See the <a href="https://docs.smooch.io/guide/conversation-referrals/">conversation referrals</a> guide for more details.
         */
        conversation?: ConversationTruncated
        /**
         * The user associated with the conversation.
         */
        user?: UserWritable
        /**
         * The source of the referral.
         */
        source?: SourceWithCampaignWebhook
        referral?: Referral
    }
}

/**
 * conversation:typing
 */
export type ConversationTypingEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the activity was sent.
         */
        conversation?: ConversationTruncated
        /**
         * The activity that was sent.
         */
        activity?: ActivityReadable & {
            /**
             * The type of activity.
             */
            type?: string
        }
    }
}

/**
 * conversation:typing
 */
export type ConversationTypingEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation in which the activity was sent.
         */
        conversation?: ConversationTruncated
        /**
         * The activity that was sent.
         */
        activity?: ActivityWritable & {
            /**
             * The type of activity.
             */
            type?: string
        }
    }
}

/**
 * switchboard:acceptControl
 */
export type SwitchboardAcceptControl = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation from which the switchboard event was fired. Will include an `activeSwitchboardIntegration` representing the integration that has just accepted control.
         */
        conversation?: ConversationTruncated
        metadata?: Metadata
    }
}

/**
 * switchboard:acceptControl:failure
 */
export type SwitchboardAcceptControlFailure = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * Object containing details of what went wrong.
         */
        error?: {
            [key: string]: unknown
        }
        /**
         * The conversation from which the switchboard event was fired.
         */
        conversation?: ConversationTruncated
        metadata?: Metadata
    }
}

/**
 * switchboard:offerControl
 */
export type SwitchboardOfferControl = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation from which the switchboard event was fired. On success, the payload will include an `activeSwitchboardIntegration`, representing the integration from which control is being offered, and a `pendingSwitchboardIntegration`, representing the integration being offered control.
         */
        conversation?: ConversationTruncated
        metadata?: Metadata
    }
}

/**
 * switchboard:offerControl:failure
 */
export type SwitchboardOfferControlFailure = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * Object containing details of what went wrong.
         */
        error?: {
            [key: string]: unknown
        }
        /**
         * The conversation from which the switchboard event was fired.
         */
        conversation?: ConversationTruncated
        metadata?: Metadata
    }
}

/**
 * switchboard:passControl
 */
export type SwitchboardPassControl = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The conversation from which the switchboard event was fired. On success, the payload will include an `activeSwitchboardIntegration`, representing the switchboard integration that is now in control of the conversation.
         */
        conversation?: ConversationTruncated
        metadata?: Metadata
    }
}

/**
 * switchboard:passControl:failure
 */
export type SwitchboardPassControlFailure = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * Object containing details of what went wrong.
         */
        error?: {
            [key: string]: unknown
        }
        /**
         * The conversation from which the switchboard event was fired.
         */
        conversation?: ConversationTruncated
        metadata?: Metadata
    }
}

/**
 * user:merge
 */
export type UserMergeEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * Contains information about the users that were merged together.
         */
        mergedUsers?: {
            /**
             * The user that now represents the merged user object.
             */
            surviving?: UserReadable
            /**
             * The user that was unified into the surviving user object.
             */
            discarded?: UserReadable
        }
        /**
         * Contains information about the conversations that were merged together as a result of the operation, if applicable. If no conversations were merged, this property is omitted.
         */
        mergedConversations?: {
            /**
             * The conversation that now represents the merged conversation object.
             */
            surviving?: ConversationTruncated
            /**
             * The conversation that was unified into the surviving conversation object.
             */
            discarded?: ConversationTruncated
        } | null
        /**
         * Contains information about the clients that were merged together as a result of the operation, if applicable. If no clients were merged, this property is omitted.
         */
        mergedClients?: {
            /**
             * The client that already existed before the merge started.
             */
            surviving?: Client
            /**
             * The pending client that was discarded during the merge event.
             */
            discarded?: Client
        } | null
        /**
         * A flat object with the set of metadata properties that were discarded when merging the two users. This should contain values only if the combined metadata fields exceed the 4KB limit.
         */
        discardedMetadata?: Metadata | null
        /**
         * The reason for which the users merged.
         * * `api` - The users were merged using the API.
         * * `channelLinking` - The users were merged as a result of initiating a channel link.
         * * `sdkLogin` - The users were merged as a result of logging into an SDK device.
         *
         */
        reason?: 'api' | 'channelLinking' | 'sdkLogin'
    }
}

/**
 * user:merge
 */
export type UserMergeEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * Contains information about the users that were merged together.
         */
        mergedUsers?: {
            /**
             * The user that now represents the merged user object.
             */
            surviving?: UserWritable
            /**
             * The user that was unified into the surviving user object.
             */
            discarded?: UserWritable
        }
        /**
         * Contains information about the conversations that were merged together as a result of the operation, if applicable. If no conversations were merged, this property is omitted.
         */
        mergedConversations?: {
            /**
             * The conversation that now represents the merged conversation object.
             */
            surviving?: ConversationTruncated
            /**
             * The conversation that was unified into the surviving conversation object.
             */
            discarded?: ConversationTruncated
        } | null
        /**
         * Contains information about the clients that were merged together as a result of the operation, if applicable. If no clients were merged, this property is omitted.
         */
        mergedClients?: {
            /**
             * The client that already existed before the merge started.
             */
            surviving?: Client
            /**
             * The pending client that was discarded during the merge event.
             */
            discarded?: Client
        } | null
        /**
         * A flat object with the set of metadata properties that were discarded when merging the two users. This should contain values only if the combined metadata fields exceed the 4KB limit.
         */
        discardedMetadata?: Metadata | null
        /**
         * The reason for which the users merged.
         * * `api` - The users were merged using the API.
         * * `channelLinking` - The users were merged as a result of initiating a channel link.
         * * `sdkLogin` - The users were merged as a result of logging into an SDK device.
         *
         */
        reason?: 'api' | 'channelLinking' | 'sdkLogin'
    }
}

/**
 * user:update
 */
export type UserUpdateEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The updated user.
         */
        user?: UserReadable
        /**
         * The reason why the user was updated, if applicable.
         * * `authentication` - An anonymous user became an [identified](https://docs.smooch.io/guide/intro-to-users/) user.
         * * `localeDetection` - A user was updated as a result of automated locale detection on messages sent.
         *
         */
        reason?: 'authentication' | 'localeDetection'
        /**
         * The source of the creation.
         */
        source?: SourceWebhook
    }
}

/**
 * user:update
 */
export type UserUpdateEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The updated user.
         */
        user?: UserWritable
        /**
         * The reason why the user was updated, if applicable.
         * * `authentication` - An anonymous user became an [identified](https://docs.smooch.io/guide/intro-to-users/) user.
         * * `localeDetection` - A user was updated as a result of automated locale detection on messages sent.
         *
         */
        reason?: 'authentication' | 'localeDetection'
        /**
         * The source of the creation.
         */
        source?: SourceWebhook
    }
}

/**
 * user:remove
 */
export type UserRemoveEventReadable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The user that was removed.
         */
        user?: UserTruncatedReadable
    }
}

/**
 * user:remove
 */
export type UserRemoveEventWritable = EventSubSchema & {
    /**
     * The payload of the event. The contents of this object depend on the type of event.
     */
    payload?: {
        /**
         * The user that was removed.
         */
        user?: UserTruncatedWritable
    }
}

/**
 * Contains parameters for applying cursor pagination.
 */
export type PageQuery = Page

/**
 * appListFilter
 * Contains parameters for filtering the results.
 */
export type AppFilterQuery = {
    /**
     * When specified, lists only the apps that the service account has access to.
     */
    serviceAccountId?: string
}

/**
 * Identifies the app.
 */
export type AppId = string

/**
 * The id of the key.
 */
export type KeyId = string

/**
 * The access level for the attachment. Currently the only available access level is public. Private is not supported.
 */
export type AccessQuery = string

/**
 * Specifies the intended container for the attachment, to enable automatic attachment deletion (on deletion of associated message, conversation or user). For now, only message is supported. See [Attachments for Messages](#section/Attachments-for-Messages) for details.
 */
export type ForQuery = string

/**
 * Links the attachment getting uploaded to the conversation ID.
 */
export type ConversationIdQuery = string

/**
 * conversationListFilter
 * Contains parameters for filtering the results.
 */
export type ConversationFilterQuery = {
    /**
     * The user's id. One of `userId` or `userExternalId` is required, but not both.
     */
    userId?: string
    /**
     * The external Id of the user. One of `userId` or `userExternalId` is required, but not both.
     */
    userExternalId?: string
}

/**
 * Identifies the conversation.
 */
export type ConversationId = string

/**
 * The id of the message.
 */
export type MessageId = string

/**
 * integrationListFilter
 * Contains parameters for filtering the results.
 */
export type IntegrationFilterQuery = {
    /**
     * Comma-separated list of types to return. If omitted, all types are returned.
     */
    types?: string
}

/**
 * The id of the integration.
 */
export type IntegrationId = string

/**
 * The id of the webhook.
 */
export type WebhookId = string

/**
 * Identifies the switchboard.
 */
export type SwitchboardId = string

/**
 * Identifies the switchboard integration.
 */
export type SwitchboardIntegrationId2 = string

/**
 * The user's id or externalId.
 */
export type UserIdOrExternalId = string

/**
 * The client's id.
 */
export type ClientId = string

/**
 * The device's id.
 */
export type DeviceId = string

/**
 * The ID that links a messaging user to its core Zendesk user counterpart. This ID can be used to fetch the core user record via the Zendesk Support API.
 *
 */
export type ZendeskId = string

/**
 * Your integration’s unique identifier
 */
export type ClientIdQuery = string

/**
 * For now the only acceptable value is code.
 */
export type ResponseTypeQuery = string

/**
 * You may pass in any arbitrary string value here which will be returned to you along with the code via browser redirect.
 */
export type StateQuery = string

/**
 * You may pass in a redirect_uri to determine which URI the response is redirected to. This URI must be contained in the list configured by your integration. If this option is not passed, the first URI present in the list will be used.
 */
export type RedirectUriQuery = string

export type ListAppsData = {
    body?: never
    path?: never
    query?: {
        /**
         * Contains parameters for applying cursor pagination.
         */
        page?: Page
        /**
         * appListFilter
         * Contains parameters for filtering the results.
         */
        filter?: {
            /**
             * When specified, lists only the apps that the service account has access to.
             */
            serviceAccountId?: string
        }
    }
    url: '/v2/apps'
}

export type ListAppsErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Forbidden
     */
    403: ErrorResponse
}

export type ListAppsError = ListAppsErrors[keyof ListAppsErrors]

export type ListAppsResponses = {
    /**
     * Ok
     */
    200: AppListResponse
}

export type ListAppsResponse = ListAppsResponses[keyof ListAppsResponses]

export type CreateAppData = {
    body: AppCreateBody
    path?: never
    query?: never
    url: '/v2/apps'
}

export type CreateAppErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Payment required
     */
    402: ErrorResponse
}

export type CreateAppError = CreateAppErrors[keyof CreateAppErrors]

export type CreateAppResponses = {
    /**
     * Created
     */
    201: AppResponse
}

export type CreateAppResponse = CreateAppResponses[keyof CreateAppResponses]

export type DeleteAppData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}'
}

export type DeleteAppErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteAppError = DeleteAppErrors[keyof DeleteAppErrors]

export type DeleteAppResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteAppResponse = DeleteAppResponses[keyof DeleteAppResponses]

export type GetAppData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}'
}

export type GetAppErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetAppError = GetAppErrors[keyof GetAppErrors]

export type GetAppResponses = {
    /**
     * Ok
     */
    200: AppResponse
}

export type GetAppResponse = GetAppResponses[keyof GetAppResponses]

export type UpdateAppData = {
    body: AppUpdateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}'
}

export type UpdateAppErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateAppError = UpdateAppErrors[keyof UpdateAppErrors]

export type UpdateAppResponses = {
    /**
     * Ok
     */
    200: AppResponse
}

export type UpdateAppResponse = UpdateAppResponses[keyof UpdateAppResponses]

export type ListAppKeysData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/keys'
}

export type ListAppKeysResponses = {
    /**
     * Ok
     */
    200: AppKeyListResponse
}

export type ListAppKeysResponse =
    ListAppKeysResponses[keyof ListAppKeysResponses]

export type CreateAppKeyData = {
    /**
     * AppKeyCreateBody
     */
    body: {
        /**
         * The name of the API key.
         */
        displayName: DisplayName
    }
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/keys'
}

export type CreateAppKeyResponses = {
    /**
     * Created
     */
    201: AppKeyResponse
}

export type CreateAppKeyResponse =
    CreateAppKeyResponses[keyof CreateAppKeyResponses]

export type DeleteAppKeyData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the key.
         */
        keyId: string
    }
    query?: never
    url: '/v2/apps/{appId}/keys/{keyId}'
}

export type DeleteAppKeyErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteAppKeyError = DeleteAppKeyErrors[keyof DeleteAppKeyErrors]

export type DeleteAppKeyResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteAppKeyResponse =
    DeleteAppKeyResponses[keyof DeleteAppKeyResponses]

export type GetAppKeyData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the key.
         */
        keyId: string
    }
    query?: never
    url: '/v2/apps/{appId}/keys/{keyId}'
}

export type GetAppKeyErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetAppKeyError = GetAppKeyErrors[keyof GetAppKeyErrors]

export type GetAppKeyResponses = {
    /**
     * Ok
     */
    200: AppKeyResponse
}

export type GetAppKeyResponse = GetAppKeyResponses[keyof GetAppKeyResponses]

export type UploadAttachmentData = {
    body: AttachmentUploadBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query: {
        /**
         * The access level for the attachment. Currently the only available access level is public. Private is not supported.
         */
        access: string
        /**
         * Specifies the intended container for the attachment, to enable automatic attachment deletion (on deletion of associated message, conversation or user). For now, only message is supported. See [Attachments for Messages](#section/Attachments-for-Messages) for details.
         */
        for?: string
        /**
         * Links the attachment getting uploaded to the conversation ID.
         */
        conversationId?: string
    }
    url: '/v2/apps/{appId}/attachments'
}

export type UploadAttachmentErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
}

export type UploadAttachmentError =
    UploadAttachmentErrors[keyof UploadAttachmentErrors]

export type UploadAttachmentResponses = {
    /**
     * Created
     */
    201: AttachmentResponse
}

export type UploadAttachmentResponse =
    UploadAttachmentResponses[keyof UploadAttachmentResponses]

export type DeleteAttachmentData = {
    body: AttachmentDeleteBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/attachments/remove'
}

export type DeleteAttachmentErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteAttachmentError =
    DeleteAttachmentErrors[keyof DeleteAttachmentErrors]

export type DeleteAttachmentResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteAttachmentResponse =
    DeleteAttachmentResponses[keyof DeleteAttachmentResponses]

export type ListConversationsData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query: {
        /**
         * Contains parameters for applying cursor pagination.
         */
        page?: Page
        /**
         * conversationListFilter
         * Contains parameters for filtering the results.
         */
        filter: {
            /**
             * The user's id. One of `userId` or `userExternalId` is required, but not both.
             */
            userId?: string
            /**
             * The external Id of the user. One of `userId` or `userExternalId` is required, but not both.
             */
            userExternalId?: string
        }
    }
    url: '/v2/apps/{appId}/conversations'
}

export type ListConversationsErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ListConversationsError =
    ListConversationsErrors[keyof ListConversationsErrors]

export type ListConversationsResponses = {
    /**
     * Ok
     */
    200: ConversationListResponse
}

export type ListConversationsResponse =
    ListConversationsResponses[keyof ListConversationsResponses]

export type CreateConversationData = {
    body: ConversationCreateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations'
}

export type CreateConversationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type CreateConversationError =
    CreateConversationErrors[keyof CreateConversationErrors]

export type CreateConversationResponses = {
    /**
     * Created
     */
    201: ConversationResponse
}

export type CreateConversationResponse =
    CreateConversationResponses[keyof CreateConversationResponses]

export type DeleteConversationData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}'
}

export type DeleteConversationErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteConversationError =
    DeleteConversationErrors[keyof DeleteConversationErrors]

export type DeleteConversationResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteConversationResponse =
    DeleteConversationResponses[keyof DeleteConversationResponses]

export type GetConversationData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}'
}

export type GetConversationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetConversationError =
    GetConversationErrors[keyof GetConversationErrors]

export type GetConversationResponses = {
    /**
     * Ok
     */
    200: ConversationResponse
}

export type GetConversationResponse =
    GetConversationResponses[keyof GetConversationResponses]

export type UpdateConversationData = {
    body: ConversationUpdateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}'
}

export type UpdateConversationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateConversationError =
    UpdateConversationErrors[keyof UpdateConversationErrors]

export type UpdateConversationResponses = {
    /**
     * Ok
     */
    200: ConversationResponse
}

export type UpdateConversationResponse =
    UpdateConversationResponses[keyof UpdateConversationResponses]

export type JoinConversationData = {
    body: ParticipantJoinBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/join'
}

export type JoinConversationErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type JoinConversationError =
    JoinConversationErrors[keyof JoinConversationErrors]

export type JoinConversationResponses = {
    /**
     * ParticipantResponse
     * The created participant.
     */
    201: {
        participant?: Participant
    }
}

export type JoinConversationResponse =
    JoinConversationResponses[keyof JoinConversationResponses]

export type ListParticipantsData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: {
        /**
         * Contains parameters for applying cursor pagination.
         */
        page?: Page
    }
    url: '/v2/apps/{appId}/conversations/{conversationId}/participants'
}

export type ListParticipantsErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ListParticipantsError =
    ListParticipantsErrors[keyof ListParticipantsErrors]

export type ListParticipantsResponses = {
    /**
     * Ok
     */
    200: ParticipantListResponse
}

export type ListParticipantsResponse =
    ListParticipantsResponses[keyof ListParticipantsResponses]

export type LeaveConversationData = {
    body: ParticipantLeaveBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/leave'
}

export type LeaveConversationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type LeaveConversationError =
    LeaveConversationErrors[keyof LeaveConversationErrors]

export type LeaveConversationResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type LeaveConversationResponse =
    LeaveConversationResponses[keyof LeaveConversationResponses]

export type DeleteAllMessagesData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/messages'
}

export type DeleteAllMessagesErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteAllMessagesError =
    DeleteAllMessagesErrors[keyof DeleteAllMessagesErrors]

export type DeleteAllMessagesResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteAllMessagesResponse =
    DeleteAllMessagesResponses[keyof DeleteAllMessagesResponses]

export type ListMessagesData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: {
        /**
         * Contains parameters for applying cursor pagination.
         */
        page?: Page
    }
    url: '/v2/apps/{appId}/conversations/{conversationId}/messages'
}

export type ListMessagesErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ListMessagesError = ListMessagesErrors[keyof ListMessagesErrors]

export type ListMessagesResponses = {
    /**
     * Ok
     */
    200: MessageListResponseReadable
}

export type ListMessagesResponse =
    ListMessagesResponses[keyof ListMessagesResponses]

export type PostMessageData = {
    body: MessagePostWritable
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/messages'
}

export type PostMessageErrors = {
    /**
     * Message limit reached
     * <aside class="notice">To learn more about the conversation message limit, consult the section in the introduction linked <a href="#section/Introduction/Conversation-Size-Limits">here</a>.</aside>
     *
     */
    423: ErrorResponse
}

export type PostMessageError = PostMessageErrors[keyof PostMessageErrors]

export type PostMessageResponses = {
    /**
     * Created
     */
    201: MessagePostResponseReadable
}

export type PostMessageResponse =
    PostMessageResponses[keyof PostMessageResponses]

export type DeleteMessageData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
        /**
         * The id of the message.
         */
        messageId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/messages/{messageId}'
}

export type DeleteMessageErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteMessageError = DeleteMessageErrors[keyof DeleteMessageErrors]

export type DeleteMessageResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteMessageResponse =
    DeleteMessageResponses[keyof DeleteMessageResponses]

export type PostActivityData = {
    body: ActivityPostWritable
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/activity'
}

export type PostActivityResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type PostActivityResponse =
    PostActivityResponses[keyof PostActivityResponses]

export type AcceptControlData = {
    body: AcceptControlBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/acceptControl'
}

export type AcceptControlErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type AcceptControlError = AcceptControlErrors[keyof AcceptControlErrors]

export type AcceptControlResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type AcceptControlResponse =
    AcceptControlResponses[keyof AcceptControlResponses]

export type OfferControlData = {
    body: OfferControlBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/offerControl'
}

export type OfferControlErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type OfferControlError = OfferControlErrors[keyof OfferControlErrors]

export type OfferControlResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type OfferControlResponse =
    OfferControlResponses[keyof OfferControlResponses]

export type PassControlData = {
    body: PassControlBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/passControl'
}

export type PassControlErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type PassControlError = PassControlErrors[keyof PassControlErrors]

export type PassControlResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type PassControlResponse =
    PassControlResponses[keyof PassControlResponses]

export type ReleaseControlData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/releaseControl'
}

export type ReleaseControlErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ReleaseControlError =
    ReleaseControlErrors[keyof ReleaseControlErrors]

export type ReleaseControlResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type ReleaseControlResponse =
    ReleaseControlResponses[keyof ReleaseControlResponses]

export type DownloadMessageRefData = {
    body: DownloadMessageRefBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the conversation.
         */
        conversationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/conversations/{conversationId}/download'
}

export type DownloadMessageRefResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DownloadMessageRefResponse =
    DownloadMessageRefResponses[keyof DownloadMessageRefResponses]

export type ListIntegrationsData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: {
        /**
         * Contains parameters for applying cursor pagination.
         */
        page?: Page
        /**
         * integrationListFilter
         * Contains parameters for filtering the results.
         */
        filter?: {
            /**
             * Comma-separated list of types to return. If omitted, all types are returned.
             */
            types?: string
        }
    }
    url: '/v2/apps/{appId}/integrations'
}

export type ListIntegrationsErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
}

export type ListIntegrationsError =
    ListIntegrationsErrors[keyof ListIntegrationsErrors]

export type ListIntegrationsResponses = {
    /**
     * Ok
     */
    200: IntegrationListResponseReadable
}

export type ListIntegrationsResponse =
    ListIntegrationsResponses[keyof ListIntegrationsResponses]

export type CreateIntegrationData = {
    body: IntegrationWritable
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations'
}

export type CreateIntegrationErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
}

export type CreateIntegrationError =
    CreateIntegrationErrors[keyof CreateIntegrationErrors]

export type CreateIntegrationResponses = {
    /**
     * The created integration.
     */
    201: IntegrationResponseReadable
}

export type CreateIntegrationResponse =
    CreateIntegrationResponses[keyof CreateIntegrationResponses]

export type DeleteIntegrationData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}'
}

export type DeleteIntegrationErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteIntegrationError =
    DeleteIntegrationErrors[keyof DeleteIntegrationErrors]

export type DeleteIntegrationResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteIntegrationResponse =
    DeleteIntegrationResponses[keyof DeleteIntegrationResponses]

export type GetIntegrationData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}'
}

export type GetIntegrationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetIntegrationError =
    GetIntegrationErrors[keyof GetIntegrationErrors]

export type GetIntegrationResponses = {
    /**
     * The fetched integration.
     */
    200: IntegrationResponseReadable
}

export type GetIntegrationResponse =
    GetIntegrationResponses[keyof GetIntegrationResponses]

export type UpdateIntegrationData = {
    body: IntegrationUpdateWritable
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}'
}

export type UpdateIntegrationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateIntegrationError =
    UpdateIntegrationErrors[keyof UpdateIntegrationErrors]

export type UpdateIntegrationResponses = {
    /**
     * The updated integration.
     */
    200: IntegrationResponseReadable
}

export type UpdateIntegrationResponse =
    UpdateIntegrationResponses[keyof UpdateIntegrationResponses]

export type ListCustomIntegrationKeysData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/keys'
}

export type ListCustomIntegrationKeysErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
}

export type ListCustomIntegrationKeysError =
    ListCustomIntegrationKeysErrors[keyof ListCustomIntegrationKeysErrors]

export type ListCustomIntegrationKeysResponses = {
    /**
     * IntegrationApiKeyListResponse
     * Ok
     */
    200: {
        /**
         * Integration keys of the supplied integration.
         */
        keys?: Array<ApiKey>
    }
}

export type ListCustomIntegrationKeysResponse =
    ListCustomIntegrationKeysResponses[keyof ListCustomIntegrationKeysResponses]

export type CreateCustomIntegrationKeyData = {
    /**
     * IntegrationApiKey
     */
    body: {
        /**
         * The name of the API key.
         */
        displayName: string
    }
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/keys'
}

export type CreateCustomIntegrationKeyResponses = {
    /**
     * Created
     */
    201: IntegrationApiKeyResponse
}

export type CreateCustomIntegrationKeyResponse =
    CreateCustomIntegrationKeyResponses[keyof CreateCustomIntegrationKeyResponses]

export type DeleteCustomIntegrationKeyData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
        /**
         * The id of the key.
         */
        keyId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/keys/{keyId}'
}

export type DeleteCustomIntegrationKeyResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteCustomIntegrationKeyResponse =
    DeleteCustomIntegrationKeyResponses[keyof DeleteCustomIntegrationKeyResponses]

export type GetCustomIntegrationKeyData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
        /**
         * The id of the key.
         */
        keyId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/keys/{keyId}'
}

export type GetCustomIntegrationKeyResponses = {
    /**
     * Ok
     */
    200: IntegrationApiKeyResponse
}

export type GetCustomIntegrationKeyResponse =
    GetCustomIntegrationKeyResponses[keyof GetCustomIntegrationKeyResponses]

export type ListWebhooksData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/webhooks'
}

export type ListWebhooksErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ListWebhooksError = ListWebhooksErrors[keyof ListWebhooksErrors]

export type ListWebhooksResponses = {
    /**
     * Ok
     */
    200: WebhookListResponseReadable
}

export type ListWebhooksResponse =
    ListWebhooksResponses[keyof ListWebhooksResponses]

export type CreateWebhookData = {
    body: WebhookCreateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/webhooks'
}

export type CreateWebhookErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Forbidden
     */
    403: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type CreateWebhookError = CreateWebhookErrors[keyof CreateWebhookErrors]

export type CreateWebhookResponses = {
    /**
     * Created
     */
    201: WebhookResponseReadable
}

export type CreateWebhookResponse =
    CreateWebhookResponses[keyof CreateWebhookResponses]

export type DeleteWebhookData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
        /**
         * The id of the webhook.
         */
        webhookId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/webhooks/{webhookId}'
}

export type DeleteWebhookErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteWebhookError = DeleteWebhookErrors[keyof DeleteWebhookErrors]

export type DeleteWebhookResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteWebhookResponse =
    DeleteWebhookResponses[keyof DeleteWebhookResponses]

export type GetWebhookData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
        /**
         * The id of the webhook.
         */
        webhookId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/webhooks/{webhookId}'
}

export type GetWebhookErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetWebhookError = GetWebhookErrors[keyof GetWebhookErrors]

export type GetWebhookResponses = {
    /**
     * Ok
     */
    200: WebhookResponseReadable
}

export type GetWebhookResponse = GetWebhookResponses[keyof GetWebhookResponses]

export type UpdateWebhookData = {
    body: WebhookBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The id of the integration.
         */
        integrationId: string
        /**
         * The id of the webhook.
         */
        webhookId: string
    }
    query?: never
    url: '/v2/apps/{appId}/integrations/{integrationId}/webhooks/{webhookId}'
}

export type UpdateWebhookErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateWebhookError = UpdateWebhookErrors[keyof UpdateWebhookErrors]

export type UpdateWebhookResponses = {
    /**
     * Ok
     */
    200: WebhookResponseReadable
}

export type UpdateWebhookResponse =
    UpdateWebhookResponses[keyof UpdateWebhookResponses]

export type ListSwitchboardsData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards'
}

export type ListSwitchboardsErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ListSwitchboardsError =
    ListSwitchboardsErrors[keyof ListSwitchboardsErrors]

export type ListSwitchboardsResponses = {
    /**
     * Ok
     */
    200: SwitchboardListResponse
}

export type ListSwitchboardsResponse =
    ListSwitchboardsResponses[keyof ListSwitchboardsResponses]

export type CreateSwitchboardData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards'
}

export type CreateSwitchboardErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type CreateSwitchboardError =
    CreateSwitchboardErrors[keyof CreateSwitchboardErrors]

export type CreateSwitchboardResponses = {
    /**
     * Created
     */
    201: SwitchboardResponse
}

export type CreateSwitchboardResponse =
    CreateSwitchboardResponses[keyof CreateSwitchboardResponses]

export type DeleteSwitchboardData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the switchboard.
         */
        switchboardId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards/{switchboardId}'
}

export type DeleteSwitchboardErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteSwitchboardError =
    DeleteSwitchboardErrors[keyof DeleteSwitchboardErrors]

export type DeleteSwitchboardResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteSwitchboardResponse =
    DeleteSwitchboardResponses[keyof DeleteSwitchboardResponses]

export type UpdateSwitchboardData = {
    body: SwitchboardUpdateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the switchboard.
         */
        switchboardId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards/{switchboardId}'
}

export type UpdateSwitchboardErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateSwitchboardError =
    UpdateSwitchboardErrors[keyof UpdateSwitchboardErrors]

export type UpdateSwitchboardResponses = {
    /**
     * Ok
     */
    200: SwitchboardResponse
}

export type UpdateSwitchboardResponse =
    UpdateSwitchboardResponses[keyof UpdateSwitchboardResponses]

export type ListSwitchboardIntegrationsData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the switchboard.
         */
        switchboardId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards/{switchboardId}/switchboardIntegrations'
}

export type ListSwitchboardIntegrationsErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type ListSwitchboardIntegrationsError =
    ListSwitchboardIntegrationsErrors[keyof ListSwitchboardIntegrationsErrors]

export type ListSwitchboardIntegrationsResponses = {
    /**
     * Ok
     */
    200: SwitchboardIntegrationListResponse
}

export type ListSwitchboardIntegrationsResponse =
    ListSwitchboardIntegrationsResponses[keyof ListSwitchboardIntegrationsResponses]

export type CreateSwitchboardIntegrationData = {
    body: SwitchboardIntegrationCreateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the switchboard.
         */
        switchboardId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards/{switchboardId}/switchboardIntegrations'
}

export type CreateSwitchboardIntegrationErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type CreateSwitchboardIntegrationError =
    CreateSwitchboardIntegrationErrors[keyof CreateSwitchboardIntegrationErrors]

export type CreateSwitchboardIntegrationResponses = {
    /**
     * Created
     */
    201: SwitchboardIntegrationResponse
}

export type CreateSwitchboardIntegrationResponse =
    CreateSwitchboardIntegrationResponses[keyof CreateSwitchboardIntegrationResponses]

export type DeleteSwitchboardIntegrationData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the switchboard.
         */
        switchboardId: string
        /**
         * Identifies the switchboard integration.
         */
        switchboardIntegrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards/{switchboardId}/switchboardIntegrations/{switchboardIntegrationId}'
}

export type DeleteSwitchboardIntegrationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteSwitchboardIntegrationError =
    DeleteSwitchboardIntegrationErrors[keyof DeleteSwitchboardIntegrationErrors]

export type DeleteSwitchboardIntegrationResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteSwitchboardIntegrationResponse =
    DeleteSwitchboardIntegrationResponses[keyof DeleteSwitchboardIntegrationResponses]

export type UpdateSwitchboardIntegrationData = {
    body: SwitchboardIntegrationUpdateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * Identifies the switchboard.
         */
        switchboardId: string
        /**
         * Identifies the switchboard integration.
         */
        switchboardIntegrationId: string
    }
    query?: never
    url: '/v2/apps/{appId}/switchboards/{switchboardId}/switchboardIntegrations/{switchboardIntegrationId}'
}

export type UpdateSwitchboardIntegrationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateSwitchboardIntegrationError =
    UpdateSwitchboardIntegrationErrors[keyof UpdateSwitchboardIntegrationErrors]

export type UpdateSwitchboardIntegrationResponses = {
    /**
     * Ok
     */
    200: SwitchboardIntegrationResponse
}

export type UpdateSwitchboardIntegrationResponse =
    UpdateSwitchboardIntegrationResponses[keyof UpdateSwitchboardIntegrationResponses]

export type CreateUserData = {
    body: UserCreateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users'
}

export type CreateUserErrors = {
    /**
     * Conflict
     */
    409: ErrorResponse
}

export type CreateUserError = CreateUserErrors[keyof CreateUserErrors]

export type CreateUserResponses = {
    /**
     * Created
     */
    201: UserResponseReadable
}

export type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses]

export type DeleteUserData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}'
}

export type DeleteUserErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors]

export type DeleteUserResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses]

export type GetUserData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}'
}

export type GetUserErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetUserError = GetUserErrors[keyof GetUserErrors]

export type GetUserResponses = {
    /**
     * Ok
     */
    200: UserResponseReadable
}

export type GetUserResponse = GetUserResponses[keyof GetUserResponses]

export type UpdateUserData = {
    body: UserUpdateBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}'
}

export type UpdateUserErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors]

export type UpdateUserResponses = {
    /**
     * Ok
     */
    200: UserResponseReadable
}

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses]

export type ListClientsData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: {
        /**
         * Contains parameters for applying cursor pagination.
         */
        page?: Page
    }
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}/clients'
}

export type ListClientsErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
}

export type ListClientsError = ListClientsErrors[keyof ListClientsErrors]

export type ListClientsResponses = {
    /**
     * Ok
     */
    200: ClientListResponse
}

export type ListClientsResponse =
    ListClientsResponses[keyof ListClientsResponses]

export type CreateClientData = {
    body: ClientCreateWritable
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}/clients'
}

export type CreateClientResponses = {
    /**
     * ClientResponse
     * Created
     */
    201: {
        client?: Client
    }
}

export type CreateClientResponse =
    CreateClientResponses[keyof CreateClientResponses]

export type RemoveClientData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
        /**
         * The client's id.
         */
        clientId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}/clients/{clientId}'
}

export type RemoveClientErrors = {
    /**
     * Bad request
     */
    400: ErrorResponse
    /**
     * Not found
     */
    404: ErrorResponse
}

export type RemoveClientError = RemoveClientErrors[keyof RemoveClientErrors]

export type RemoveClientResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type RemoveClientResponse =
    RemoveClientResponses[keyof RemoveClientResponses]

export type ListDevicesData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}/devices'
}

export type ListDevicesResponses = {
    /**
     * Ok
     */
    200: DeviceListResponse
}

export type ListDevicesResponse =
    ListDevicesResponses[keyof ListDevicesResponses]

export type GetDeviceData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
        /**
         * The device's id.
         */
        deviceId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}/devices/{deviceId}'
}

export type GetDeviceErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type GetDeviceError = GetDeviceErrors[keyof GetDeviceErrors]

export type GetDeviceResponses = {
    /**
     * Ok
     */
    200: DeviceResponse
}

export type GetDeviceResponse = GetDeviceResponses[keyof GetDeviceResponses]

export type DeleteUserPersonalInformationData = {
    body?: never
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The user's id or externalId.
         */
        userIdOrExternalId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{userIdOrExternalId}/personalinformation'
}

export type DeleteUserPersonalInformationErrors = {
    /**
     * Not found
     */
    404: ErrorResponse
}

export type DeleteUserPersonalInformationError =
    DeleteUserPersonalInformationErrors[keyof DeleteUserPersonalInformationErrors]

export type DeleteUserPersonalInformationResponses = {
    /**
     * Ok
     */
    200: UserResponseReadable
}

export type DeleteUserPersonalInformationResponse =
    DeleteUserPersonalInformationResponses[keyof DeleteUserPersonalInformationResponses]

export type SyncUserData = {
    body?: SyncUserBody
    path: {
        /**
         * Identifies the app.
         */
        appId: string
        /**
         * The ID that links a messaging user to its core Zendesk user counterpart. This ID can be used to fetch the core user record via the Zendesk Support API.
         *
         */
        zendeskId: string
    }
    query?: never
    url: '/v2/apps/{appId}/users/{zendeskId}/sync'
}

export type SyncUserResponses = {
    /**
     * Ok
     */
    200: UserResponseReadable
}

export type SyncUserResponse = SyncUserResponses[keyof SyncUserResponses]

export type AuthorizeData = {
    body?: never
    path?: never
    query: {
        /**
         * Your integration’s unique identifier
         */
        client_id: string
        /**
         * For now the only acceptable value is code.
         */
        response_type: string
        /**
         * You may pass in any arbitrary string value here which will be returned to you along with the code via browser redirect.
         */
        state?: string
        /**
         * You may pass in a redirect_uri to determine which URI the response is redirected to. This URI must be contained in the list configured by your integration. If this option is not passed, the first URI present in the list will be used.
         */
        redirect_uri?: string
    }
    url: '/oauth/authorize'
}

export type GetTokenData = {
    body: {
        /**
         * The authorization code received via /oauth/authorize
         */
        code: string
        /**
         * Must be set to the string `authorization_code`
         */
        grant_type: string
        /**
         * Your integration’s unique identifier
         */
        client_id: string
        /**
         * Your integration’s secret
         */
        client_secret: string
    }
    path?: never
    query?: never
    url: '/oauth/token'
}

export type GetTokenResponses = {
    /**
     * Ok
     */
    200: {
        /**
         * An access token that can now be used to call Sunshine Conversations APIs.
         */
        access_token?: string
        /**
         * Bearer. All issued tokens are of this type.
         */
        token_type?: string
    }
}

export type GetTokenResponse = GetTokenResponses[keyof GetTokenResponses]

export type RevokeAccessData = {
    body?: never
    path?: never
    query?: never
    url: '/oauth/authorization'
}

export type RevokeAccessResponses = {
    /**
     * Ok
     */
    200: {
        [key: string]: unknown
    }
}

export type RevokeAccessResponse =
    RevokeAccessResponses[keyof RevokeAccessResponses]

export type ClientOptions = {
    baseUrl:
        | 'https://api.smooch.io'
        | 'https://api.eu-1.smooch.io'
        | (string & {})
}
